{
  "document_title": "BÀI GIẢNG AN NINH MẠNG VIỄN THÔNG",
  "structure_type": "Chương/Mục",
  "data": [
    {
      "level_1_title": "Chương 1: Tổng quan an toàn mạng truyền thông",
      "level_1_id": "1",
      "children": [
        {
          "level_2_title": "1.1. Khái niệm an toàn mạng truyền thông",
          "level_2_id": "1.1",
          "content": "Trước đây khi công nghệ máy tính chưa phát triển, khi nói đến vấn đề an toàn bảo mật thông tin (Information Security), chúng ta thường hay nghĩ đến các biện pháp nhằm đảm bảo cho thông tin được trao đổi hay cất giữ một cách an toàn và bí mật. Chẳng hạn là các biện pháp như:\n+ Đóng dấu và ký niêm phong một bức thư để biết rằng lá thư có được chuyển nguyên vẹn đến người nhận hay không.\n+ Dùng mật mã mã hóa thông điệp để chỉ có người gửi và người nhận hiểu được thông điệp. Phương pháp này thường được sử dụng trong chính trị và quân sự.\n+ Lưu giữ tài liệu mật trong các két sắt có khóa, tại các nơi được bảo vệ nghiêm ngặt, chỉ có những người được cấp quyền mới có thể xem tài liệu.\nVới sự phát triển mạnh mẽ của công nghệ thông tin, đặc biệt là sự phát triển của mạng Internet, ngày càng có nhiều thông tin được lưu giữ trên máy vi tính và gửi đi trên mạng Internet. Và do đó xuất hiện nhu cầu về an toàn và bảo mật thông tin trên máy tính. Có thể phân loại mô hình an toàn mạng thông tin trên máy tính theo hai hướng chính như sau:\n1) Bảo vệ thông tin trong quá trình truyền thông tin trên mạng (Network Security)\n2) Bảo vệ hệ thống máy tính, và mạng máy tính, khỏi sự xâm nhập phá hoại từ bên ngoài (System Security)",
          "children": []
        },
        {
          "level_2_title": "1.2. Kiến trúc an toàn",
          "level_2_id": "1.2",
          "content": "ITU-T đã đưa ra khuyến nghị X.800 định nghĩa kiến trúc an toàn cho mô hình OSI. Kiến trúc an toàn OSI giúp cho các nhà quản lý trong việc tổ chức cung cấp dịch vụ an toàn. Hơn nữa, do kiến trúc này được phát triển như là chuẩn quốc tế, các nhà cung cấp cơ sở hạ tầng cũng như nhà cung cấp thiết bị và dịch vụ có thể triển khai các đặc tính an toàn cho các sản phẩm và dịch vụ của họ. Kiến trúc an toàn tập trung vào các kiểu tấn công, các cơ chế an toàn, và các dịch vụ an toàn. Các đặc điểm này được định nghĩa ngắn gọn như sau:\n+ Tấn công an toàn: bất kỳ hành động nào mà làm hại đến tính an toàn thông tin của một tổ chức nào đó.\n+ Cơ chế an toàn: quá trình được thiết kế để phát hiện, ngăn ngừa, hay khôi phục lại các kiểu tấn công an toàn.\n+ Dịch vụ an toàn: dịch vụ truyền thông làm tăng cường tính an toàn của hệ thống xử lý dữ liệu và thông tin của một tổ chức. Các dịch vụ này thường dùng để chống lại các tấn công an toàn, và các dịch vụ này tận dụng một hoặc nhiều cơ chế an toàn để cung cấp dịch vụ.",
          "children": []
        },
        {
          "level_2_title": "1.3. Tấn công mạng",
          "level_2_id": "1.3",
          "content": "Về cơ bản, tấn công mạng được chia thành 2 loại đó là tấn công thụ động và tấn công tích cực. Tấn công thụ động là việc cố gắng lấy hoặc lợi dụng thông tin hệ thống nhưng không ảnh hưởng đến các tài nguyên hệ thống. Tấn công tích cực là các hành động cố gắng thay đổi các tài nguyên hệ thống hoặc gây ảnh hưởng đến hoạt động của họ.\n\n**Các kiểu tấn công thụ động**\nCác kiểu tấn công thụ động về bản chất là các hành động nghe trộm, hoặc giám sát các hoạt động truyền thông. Mục tiêu của kẻ tấn công là lấy được thông tin đang được truyền đi. Hai kiểu của tấn công thụ động là xem trộm các nội dung bản tin và phân tích luồng thông tin.\nKiểu tấn công xem trộm nội dung bản tin: cuộc điện thoại, mail điện tử, và file được truyền đi có thể chứa các thông tin bí mật hoặc nhạy cảm. Kẻ tấn công sẽ tấn công để xem trộm được các thông tin bí mật hoặc nhạy cảm đó.\nKiểu tấn công thụ động thứ hai, phân tích luồng thông tin: giả thiết rằng đã có cách để che dấu các nội dung bản tin hoặc lưu lượng thông tin khác để các kẻ tấn công, thậm chí họ chỉ bắt các bản tin, không thể tách thông tin từ bản tin đó. Kĩ thuật chung để che dấu thông tin là mật mã hóa. Nếu bản tin đã được mật mã hóa, kẻ tấn công có thể vẫn có khả năng quan sát được mẫu các bản tin này. Kẻ tấn công có thể xác định vị trí và nhận dạng các thiết bị truyền thông và có thể quan sát được tần suất và độ dài các bản tin đang được trao đổi. Thông tin này có thể là hữu ích cho việc đoán bản chất của quá trình truyền thông đang xảy ra.\nCác kiểu tấn công thụ động là rất khó để phát hiện, bởi chúng không liên quan đến bất kỳ sự thay đổi nào của dữ liệu. Cụ thể là, lưu lượng bản tin được gửi và nhận theo một cách thông thường nào đó, và cả người gửi và người nhận đều không phát hiện ra sự có mặt của bên thứ ba đang đọc các bản tin hoặc đang quan sát các mẫu lưu lượng. Tuy nhiên, có thể ngăn ngừa kiểu tấn công này bằng cách sử dụng các kiểu mật mã hóa. Do đó, đối với kiểu tấn công này, phòng ngừa tốt hơn là phát hiện.\n\n**Các kiểu tấn công tích cực**\nCác kiểu tấn công tích cực liên quan đến việc sửa đổi dòng dữ liệu hoặc tạo dòng dữ liệu sai lệch và có thể được chia thành bốn loại sau: mạo danh (Masquerade), phát lại bản tin (replay), sửa đổi bản tin, và từ chối dịch vụ.\nTấn công mạo danh: tấn công mạo danh là tấn công mà kẻ tấn công mạo danh bên gửi tin để gửi bản tin cho bên nhận. Bên nhận không biết sự mạo danh đó và vẫn nghĩ là bản tin được gửi từ bên gửi hợp lệ.\nTấn công phát lại: liên quan đến việc sao chép thụ động dữ liệu và sau đó gửi lại bản sao chép đó cho bên nhận. Thoạt đầu có thể nghĩ rằng việc phát lại này là vô hại, tuy nhiên trong nhiều trường hợp cũng gây ra tác hại không kém so với tấn công mạo danh. Xét tình huống sau: giả sử Alice là ngân hàng còn Bob là một khách hàng. Bob gửi bản tin đề nghị Alice chuyển cho Darth 1000$. Bob có áp dụng các biện pháp như chữ ký điện tử với mục đích không cho Darth mạo danh cũng như sửa thông tin. Tuy nhiên nếu Darth sao chép và phát lại bản tin đó thì các biện pháp bảo vệ này không có ý nghĩa. Alice tin rằng Bob gửi tiếp một bản tin mới để chuyển thêm cho Darth 1000$ nữa.\nThay đổi bản tin: Darth chặn các bản tin Bob gửi cho Alice và ngăn không cho các bản tin này đến đích. Sau đó Darth thay đổi nội dung của bản tin và gửi tiếp cho Alice. Alice nghĩ rằng nhận được bản tin nguyên bản ban đầu của Bob mà không biết rằng chúng đã bị sửa đổi. Ví dụ, Bob gửi bản tin cho Alice là “Cho phép John đọc được các account file bí mật”, bản tin đó bị sửa đổi thành “Cho phép Fred đọc được các account file bí mật\".\nTấn công từ chối dịch vụ: kiểu tấn công này có một mục tiêu cụ thể; ví dụ kẻ tấn công chặn toàn bộ các bản tin được chuyển tới một đích nào đó. Một loại hình khác của kiểu tấn công này là làm sập hoàn toàn mạng, có thể bằng cách làm mất khả năng hoạt động của mang hoặc làm quá tải mạng với các bản tin gửi liên tiếp tới mạng đó để làm suy giảm hiệu năng mạng.\nKiểu tấn công tích cực có thể có chủ ý cụ thể, ví dụ một kẻ tấn công có thể ngăn cản tất cả các thông báo được chuyển tới một đích nào đó, vô hiệu hoá một mạng hoặc tạo ra tình trạng quá tải với các thông báo của họ làm giảm hiệu năng mạng.\nCó thể thấy rằng hai kiểu tấn công chủ động và thụ động có những đặc trưng khác nhau. Kiểu tấn công thụ động khó phát hiện nhưng có biện pháp để ngăn chặn thành công. Mặt khác kiểu tấn công chủ động dễ phát hiện nhưng lại rất khó ngăn chặn tuyệt đối, nó cũng đòi hỏi việc bảo vệ vật lý tất cả các phương tiện truyền thông ở mọi lúc, mọi nơi. Giải pháp để chống lại kiểu tấn công này là phát hiện chúng và khôi phục mạng khi bị phá vỡ hoặc khi thông tin bị trễ.",
          "children": []
        },
        {
          "level_2_title": "1.4. Dịch vụ an toàn",
          "level_2_id": "1.4",
          "content": "X.800 định nghĩa dịch vụ an toàn là một dịch vụ được cung cấp bởi lớp giao thức của các hệ thống truyền thông và đảm bảo tính an toàn của các hệ thống hoặc của việc truyền dữ liệu. RFC 4949 định nghĩa dịch vụ an toàn thực hiện các chính sách an toàn và được thực thi bởi các cơ chế an toàn. X.800 chia các dịch vụ này thành năm loại và 14 dịch vụ cụ thể như sau.\n\n**Dịch vụ xác thực:**\nDịch vụ xác thực liên quan đến việc đảm bảo rằng quá trình truyền thông được xác thực nghĩa là cả người gửi và người nhận không bị mạo danh. Trong trường hợp chỉ có một thông tin, như là tín hiệu cảnh báo hoặc báo thức, chức năng của dịch vụ xác thực là đảm bảo với người nhận rằng bản tin đó đến từ nguồn được xác thực. Trong trường hợp có sự tương tác xảy ra, ví dụ như sự kết nối của đầu cuối với thiết bị đầu cuối khác, đầu tiên, tại thời điểm khởi tạo kết nối, dịch vụ xác thực đảm bảo rằng hai thực thể đều được xác thực. Sau đó, dịch vụ này phải đảm bảo rằng kết nối là không bị cản trở theo cách đó bên thứ ba có thể mạo danh như là một trong hai bên hợp pháp để thực hiện việc nhận và truyền dẫn không được phép.\nHai loại dịch vụ xác thực được định nghĩa trong X.800:\n+ Xác thực toàn bộ các peer: cung cấp chứng thực nhận dạng thực thể peer trong một liên kết. Hai thực thể được gọi là peer nếu chúng thực thi cùng giao thức trong các hệ thống khác nhau. Xác thực peer được thực hiện tại thời điểm thiết lập kết nối hoặc tại các thời điểm trong suốt pha truyền dữ liệu của kết nối.\n+ Xác thực dữ liệu: cung cấp chứng thực nguồn dữ liệu. Dịch vụ này không cung cấp bảo vệ chống lại việc nhân bản hoặc chỉnh sửa dữ liệu. Kiểu dịch vụ này hỗ trợ các ứng dụng không có tương tác trước đó giữa các thực thể truyền thông như thư điện tử.\n\n**Điều khiển truy nhập**\nTrong ngữ cảnh an toàn mạng, điều khiển truy nhập có khả năng hạn chế và điều khiển việc truy nhập tới các hệ thống và các ứng dụng qua các liên kết truyền thông. Để đạt được điều này, mỗi thực thể cố gắng truy nhập đầu tiên phải được nhận dạng, hoặc nhận thực, thì mới được phép truy cập các phần tử mạng, thông tin lưu trữ, luồng thông tin, dịch vụ và ứng dụng mạng.\n\n**Dịch vụ bảo mật dữ liệu**\nDịch vụ bảo mật dữ liệu là thực hiện bảo vệ dữ liệu được truyền đi khỏi các kiểu tấn công thụ động. Có một số mức bảo vệ được định nghĩa. Mức rộng nhất là bảo vệ toàn bộ dữ liệu của người sử dụng được truyền đi giữa hai bên qua một khoảng thời gian nào đó. Mức hẹp nhất của dịch vụ bảo mật dữ liệu là bảo vệ một bản tin đơn hoặc thậm chí một vài trường cụ thể nào đó trong một bản tin. Một khía cạnh khác của dịch vụ bảo mật là bảo vệ luồng dữ liệu khỏi kẻ tấn công. Điều đó yêu cầu kẻ tấn công không thể theo dõi được phía nguồn, phía đích, tần suất, độ dài, hay các đặc tính khác của lưu lượng trên một phương tiện truyền thông.\n\n**Dịch vụ toàn vẹn dữ liệu**\nCũng giống như dịch vụ bảo mật dữ liệu, dịch vụ toàn vẹn dữ liệu có khả năng áp dụng cho một dòng bản tin, một bản tin, hay một số trường xác định trong một bản tin. Dịch vụ toàn vẹn hướng kết nối đảm bảo rằng các bản tin được nhận mà không bị lặp, chèn, chỉnh sửa, sai thứ tự, hay truyền lại. Sự phá hoại dữ liệu có thể được khôi phục bởi dịch vụ này. Do đó, dịch vụ toàn vẹn hướng kết nối giải quyết được kiểu tấn công từ chối dịch vụ và chỉnh sửa dòng bản tin. Mặt khác, dịch vụ toàn vẹn hướng phi kết nối, chỉ thực hiện với từng bản tin riêng biệt, thường cung cấp sự bảo vệ chống lại việc chỉnh sửa bản tin.\n\n**Dịch vụ không thể chối bỏ (Nonrepudiation)**\nDịch vụ không thể chối bỏ ngăn chặn việc bên gửi hay bên nhận chối bỏ bản tin đã được truyền. Khi bản tin được gửi đi bên nhận có thể chứng minh rằng bên gửi hợp pháp đã gửi nó đi. Khi bản tin nhận được bên gửi có thể chứng minh rằng bản tin đó đã nhận được bởi bên nhận hợp pháp.\n\n**Các dịch vụ khả dụng**\nCả X.800 và RFC 4949 đều định nghĩa tính khả dụng là đặc tính của hệ thống hoặc tài nguyên hệ thống có khả năng truy cập và sử dụng dựa trên nhu cầu bởi một thực thể hệ thống được cấp quyền, tùy thuộc vào các đặc tả hiệu năng của hệ thống đó (nghĩa là hệ thống là khả dụng nếu nó cung cấp các dịch vụ theo thiết kế hệ thống bất cứ khi nào người sử dụng yêu cầu). Có rất nhiều kiểu tấn công có thể làm mất hoặc giảm tính khả dụng. Có một số cách tự động đối phó với các kiểu tấn công này như xác thực và mật mã hóa, trong khi một số cách khác yêu cầu một số biện pháp mức vật lý để phòng ngừa hoặc khôi phục việc mất tính khả dụng của các phần tử của các hệ thống.",
          "children": []
        },
        {
          "level_2_title": "1.5. Các cơ chế an toàn",
          "level_2_id": "1.5",
          "content": "Các cơ chế an toàn được định nghĩa trong X.800 được phân chia thành các cơ chế được thực thi trong lớp giao thức cụ thể, như TCP hay giao thức lớp ứng dụng, và các cơ chế không cụ thể với bất kỳ lớp giao thức nào hoặc dịch vụ an toàn nào. X.800 phân biệt các cơ chế mật mã hóa thuận nghịch và các cơ chế mật mã hóa không thuận nghịch. Cơ chế mật mã hóa thuận nghịch chỉ đơn giản là thuật toán mật mã cho phép dữ liệu được mật mã hóa và sau đó giải mật mã. Cơ chế mật mã hóa không thuận nghịch gồm các thuật toán hàm băm và các mã xác thực bản tin được sử dụng trong các ứng dụng xác thực và chữ ký điện tử.\nCác cơ chế an toàn xác định gồm:\n+ Mật mã hóa: sử dụng các thuật toán mật mã để biến đổi dữ liệu thành một dạng dữ liệu khác. Sự biến đổi và khôi phục dữ liệu phụ thuộc vào thuật toán và không hoặc nhiều khóa bí mật.\n+ Chữ ký số: dữ liệu được gắn thêm vào, hoặc biến đổi mật mã của, một đơn vị dữ liệu để cho phép bên nhận dữ liệu đó xác định được bên gửi và tính toàn vẹn dữ liệu, và chống lại được sự giả mạo.\n+ Điều khiển truy nhập: Các cơ chế điều khiển truy nhập được dùng để đảm bảo rằng chỉ có một số người dùng được gán quyền mới có thể truy nhập tới các tài nguyên thông tin (tệp, tiến trình, cổng truyền thông) và các tài nguyên phần cứng (máy chủ in, Processor, Gateway).\n+ Tính toàn vẹn dữ liệu: các cơ chế được sử dụng để đảm bảo tính toàn vẹn của một đơn vị dữ liệu hoặc của luồng dữ liệu.\n+ Trao đổi xác thực: được sử dụng để đảm bảo định danh của người dùng bằng cách trao đổi thông tin.\n+ Đệm lưu lượng: chèn các bit vào các khoảng trống của luồng dữ liệu để gây khó khăn cho kiểu tấn công phân tích lưu lượng.\n+ Điều khiển định tuyến: cho phép lựa chọn các tuyến an toàn cụ thể nào đó và cho phép thay đổi định tuyến đặc biệt là khi có lỗ hổng an toàn đang xảy ra.\n+ Chứng thực: sử dụng bên tin tưởng thứ 3 để đảm bảo các đặc tính xác định nào đó của việc trao đổi dữ liệu.",
          "children": []
        },
        {
          "level_2_title": "1.6. Mô hình an toàn mạng",
          "level_2_id": "1.6",
          "content": "Mô hình an toàn mạng được mô tả trong hình 1.4. Bản tin được truyền từ bên gửi đến bên nhận qua mạng Internet. Kênh thông tin logic được thiết lập bằng cách định nghĩa một tuyến qua mạng Internet từ nguồn tới đích và bằng cách sử dụng các giao thức truyền thông (TCP/IP). Các khía cạnh an toàn được yêu cầu khi cần bảo vệ quá trình truyền thông khỏi kẻ tấn công.\nTất cả các kĩ thuật cung cấp tính an toàn đều có hai thành phần:\n+ Phép biến đổi an toàn lên thông tin được gửi đi. Ví dụ như mật mã hóa bản tin hay thêm mã vào nội dung bản tin.\n+ Một số thông tin an toàn được chia sẻ bởi bên gửi và bên nhận. Ví dụ như khóa bí mật được sử dụng để mật mã hóa bản tin trước khi gửi đi.\nBên thứ ba chứng thực có thể được yêu cầu để đạt được truyền dẫn an toàn. Ví dụ, bên thứ ba có thể chịu trách nhiệm phân phối thông tin bí mật tới bên gửi và bên nhận mà không bị phát hiện bởi bất cứ kẻ tấn công nào.\nCó bốn nhiệm vụ cơ bản khi thiết kế dịch vụ an toàn cụ thể:\n1. Thiết kế một thuật toán cho việc thực hiện biến đổi liên quan đến an toàn. Thuật toán này phải đảm bảo rằng kẻ tấn công không thể đánh bại được mục đích của nó.\n2. Tạo thông tin bí mật được sử dụng cùng với thuật toán\n3. Phát triển các phương pháp phân phối và chia sẻ thông tin bí mật\n4. Chỉ rõ giao thức được sử dụng bởi bên gửi và bên nhận mà sử dụng thuật toán an toàn và thông tin bí mật để đạt được dịch vụ an toàn cụ thể.\nHình 1.5 trình bày mô hình an toàn truy nhập mạng nhằm bảo vệ hệ thống thông tin khỏi các truy nhập không mong muốn. Có hai loại tấn công đó là tấn công từ con người (hacker) và tấn công bằng các phần mềm như virus hay worm.\nCác cơ chế an toàn cần thiết để đối phó với các truy nhập không mong muốn được phân thành hai loại. Loại thứ nhất là chức năng gatekeeper. Loại này bao gồm các thủ tục đăng nhập dựa trên mật khẩu được thiết kế để bảo vệ và loại bỏ các worm, virus và các kiểu tấn công tương tự khác. Loại thứ hai bao gồm các loại điều khiển trong nội bộ nhằm mục đích giám sát các hoạt động và phân tích thông tin lưu trữ để phát hiện ra sự có mặt của kẻ xâm nhập không mong muốn.",
          "children": []
        },
        {
          "level_2_title": "1.7. Kết luận chương",
          "level_2_id": "1.7",
          "content": "Chương 1 đã giới thiệu những khái niệm cơ bản liên quan đến các vấn đề an toàn mạng truyền thông và kiến trúc an toàn. Cũng trong chương này, hai kiểu tấn công chính đó là tấn công thụ động và tấn công tích cực được trình bày. Các dịch vụ an toàn và cơ chế an toàn đã được định nghĩa và sự tương quan giữa các dịch vụ và các cơ chế này cũng được đưa ra.",
          "children": []
        },
        {
          "level_2_title": "1.8. Câu hỏi ôn tập chương 1",
          "level_2_id": "1.8",
          "content": "1. Trình bày kiến trúc an toàn mạng truyền thông.\n2. Trình bày sự khác nhau giữa kiểu tấn công thụ động và kiểu tấn công tích cực.\n3. Liệt kê và định nghĩa ngắn gọn các kiểu tấn công thụ động và tích cực\n4. Trình bày các loại dịch vụ an toàn.\n5. Trình bày các cơ chế an toàn.",
          "children": []
        }
      ]
    },
    {
      "level_1_title": "Chương 2: Mật mã khóa đối xứng",
      "level_1_id": "2",
      "children": [
        {
          "level_2_title": "2.1. Mô hình mật mã hóa khóa đối xứng",
          "level_2_id": "2.1",
          "content": "Sơ đồ mật mã hóa đối xứng bao gồm 5 thành phần như chỉ ra trong hình vẽ 2.1.\nNăm thành phần của mô hình mật mã khóa đối xứng đơn giản bao gồm:\n+ Bản rõ: đây là dữ liệu hoặc bản tin ban đầu, được xem như là đầu vào của khối thuật toán mật mã.\n+ Thuật toán mật mã hóa: thuật toán mật mã hóa thực hiện rất nhiều phép biến đổi và thay thế trên bản rõ.\n+ Khóa bí mật: khóa bí mật cũng là một đầu vào của khối thuật toán mật mã hóa. Khóa là một giá trị độc lập với bản rõ và thuật toán. Thuật toán sẽ cho ra một đầu ra khác nhau phụ thuộc vào khóa cụ thể được sử dụng tại thời điểm đó. Các phép biến đổi và thay thế chính xác được thực hiện bởi thuật toán phụ thuộc vào khóa đó.\n+ Bản mã: đây là bản tin đầu ra khối thuật toán mật mã. Bản mã này phụ thuộc vào bản rõ và khóa bí mật. Với một bản tin xác định, hai khóa khác nhau sẽ tạo ra hai bản mã khác nhau.\n+ Thuật toán giải mật mã: là thuật toán thực hiện ngược lại với thuật toán mật mã hóa. Khối này nhận bản mã và khóa bí mật để tạo ra bản rõ ban đầu.\nCó hai yêu cầu cho việc sử dụng an toàn mật mã hóa truyền thống:\n+ Một thuật toán mật mã hóa đủ mạnh được yêu cầu: tối thiểu là thuật toán mật mã hóa đó phải đảm bảo rằng kẻ tấn công (opponent) mặc dù biết được thuật toán và lấy được một hoặc nhiều bản mã nhưng không thể giải mật mã bản mã đó hoặc tìm ra khóa. Yêu cầu này thường được phát biểu như sau: kẻ tấn công không có khả năng giải mật mã bản mã hoặc khôi phục khóa thậm chí anh ta sở hữu một số các bản mã cùng với bản rõ được tạo ra từ mỗi bản mã đó.\n+ Bên gửi và bên nhận phải có bản sao của khóa bí mật, và khóa phải được giữ bí mật giữa người gửi và người nhận, hay nói cách khác khóa phải được chuyển một cách an toàn từ người gửi đến người nhận.\nGiả sử rằng việc giải mật mã bản tin là không thể thực hiện được dựa trên bản mã và sự hiểu biết về thuật toán mật mã hóa/giải mật mã. Nói cách khác, không cần phải giữ bí mật thuật toán mật mã hóa mà chỉ cần giữ bí mật khóa. Đặc điểm này của mật mã hóa đối xứng làm cho nó được sử dụng rộng rãi. Thực tế là thuật toán không cần được giữ bí mật nghĩa là các nhà sản xuất có thể và đã phát triển các mạch (chip) có chi phí thấp để thực thi các thuật toán mật mã hóa dữ liệu. Các chip này sẵn có và được tính hợp vào một số sản phẩm. Với việc sử dụng mật mã hóa đối xứng, vấn đề bảo mật được thực hiện ở việc bảo mật khóa bí mật.\nNguồn bản tin tạo ra bản tin trong chế độ bản rõ, X=[X1, X2,..., XM]. M phần tử của X là các chữ cái trong bản chữ cái (alphabet). Theo truyền thống, bảng chữ cái gồm 26 chữ cái in hoa. Ngày nay, bảng chữ cái nhị phân {0,1} được sử dụng. Đối với mật mã hóa, khóa có dạng K=[K1, K2,..., KJ] được tạo ra. Nếu khóa đó được tạo ra tại phía nguồn bản tin, thì nó cũng phải được cung cấp cho bên nhận bằng một kênh an toàn. Nếu bên thứ ba tạo ra khóa bí mật, thì khóa đó sẽ được phân phối an toàn tới cả bên gửi và nhận.\nVới bản tin X và khóa bí mật K là đầu vào, các thuật toán mật mã hóa tạo ra các bản mã Y=[Y1, Y2,..., YN], được viết như sau: Y = E(K, X)\nCông thức này chỉ ra rằng Y được tạo ra bằng cách sử dụng thuật toán mật mã hóa E là một hàm của bản rõ, X, với một hàm xác định được quyết định bởi giá trị của khóa K.\nBên nhận mong muốn, có khóa bí mật, có khả năng thực hiện phép biến đổi sau: X = D(K, Y)\nKẻ tấn công, thu được Y nhưng không có khóa K hoặc X, có thể cố gắng để khôi phục X hoặc K hoặc cả X và K. Giả thiết rằng kẻ tấn công đó biết thuật toán mật mã hóa E và thuật toán giải mật mã D. Nếu kẻ tấn công chỉ quan tâm đến một bản tin cụ thể, thì chỉ cố gằng khôi phục X bằng cách tạo ra ước lượng bản rõ, X^. Tuy nhiên, thường thì kẻ tấn công quan tâm đến khả năng đọc được các bản tin tiếp theo, trong trường hợp đó phải khôi phục K bằng cách tạo ra ước lượng K.\n\n**Mật mã (Cryptography)**\nCác hệ thống mật mã được mô tả bởi ba khía cạnh độc lập dưới đây:\n1. Kiểu các cách thức được sử dụng để biến đổi từ bản rõ thành bản mã. Tất cả các thuật toán mật mã hóa được dựa trên hai nguyên lý chung: thay thế, trong đó mỗi phần tử trong bản rõ (bit, chữ cái, nhóm bit hoặc nhóm chữ cái) được ánh xạ thành một phần tử khác; và hoán đổi vị trí, trong đó các phần tử trong bản rõ được sắp xếp lại. Yêu cầu cơ bản là không có thông tin nào bị mất (nghĩa là tất cả các hoạt động đó có thể được khôi phục). Hầu hết các hệ thống, còn được gọi là các hệ thống sản phẩm, bao gồm nhiều giai đoạn thay thế và biến đổi.\n2. Số khóa được sử dụng. Nếu cả bên gửi và bên nhận sử dụng chung khóa, hệ thống đó được gọi là hệ thống mật mã hóa đối xứng, một khóa, khóa bí mật, hay truyền thống. Nếu bên gửi và nhận sử dụng các khóa khác nhau, hệ thống đó được gọi là hệ thống mật mã hóa bất đối xứng, hai khóa, hay khóa công khai.\n3. Cách mà bản rõ được xử lý. Mật mã khối xử lý đầu vào là một khối các phần tử tại một thời điểm, tạo ra khối đầu ra cho mỗi khối đầu vào. Mật mã dòng (stream cypher) xử lý các phần tử đầu vào một cách liên tục, tạo ra phần tử một đầu ra tại một thời điểm.\n\n**Giải mã các mật mã và tấn công Brute-Force**\nMục tiêu tấn công hệ thống mật mã hóa là để khôi phục khóa đang dùng chứ không phải đơn giản là khôi phục bản rõ của một bản mã. Có hai cách chung để tấn công sơ đồ mật mã hóa truyền thống gồm:\n+ Giải mã các mật mã (Cryptanalysis): các tấn công này dựa trên bản chất của thuật toán cộng với sự hiểu biết về các đặc tính chung của bản rõ hoặc thậm chí một vài cặp bản rõ – bản mã mẫu. Kiểu tấn công này lợi dụng các đặc tính của thuật toán để cố gắng suy luận ra bản rõ cụ thể hoặc để suy ra khóa được sử dụng.\n+ Kiểu tấn công Brute - Force: kẻ tấn công thử các khóa có thể lên một đoạn bản mã cho tới khi biên dịch được thành bản rõ. Trung bình, một nửa số khóa có thể phải được thử để đạt được thành công.\nNếu một trong hai kiểu tấn công thực hiện thành công việc suy luận khóa, tất cả các bản tin trước đó và sau này đều đã được mật mã hóa sẽ bị tấn công. Một kiểu tấn công khác là tấn công Brute-Force bằng cách thử tất cả khóa có thể. Nếu không gian khóa là rất lớn, kiểu tấn công này rất khó để thực hiện. Do đó, kẻ tấn công phải dựa trên việc phân tích bản mã, thường áp dụng các thử nghiệm thống kê. Để sử dụng phương pháp này, kẻ tấn công phải có một vài ý tưởng chung về kiểu bản rõ đang được che dấu, như là bản Tiếng Anh hay Tiếng Pháp, file EXE.",
          "children": []
        },
        {
          "level_2_title": "2.2. Mật mã khối và tiêu chuẩn mật mã hóa dữ liệu DES",
          "level_2_id": "2.2",
          "content": "Mật mã khối và tiêu chuẩn mật mã hóa dữ liệu DES",
          "children": [
            {
              "level_3_title": "2.2.1. Cấu trúc mật mã khối",
              "level_3_id": "2.2.1",
              "content": "Hiện nay, rất nhiều các thuật toán mật mã hóa khối đối xứng được sử dụng dựa trên cấu trúc mật mã khối Feistel. Do đó, trong phần này chúng tôi giới thiệu cấu trúc chung của mật mã khối và cấu trúc của mật mã khối Feistel.",
              "children": [
                {
                  "level_4_title": "2.2.1.1. Cấu trúc chung của mật mã khối",
                  "level_4_id": "2.2.1.1",
                  "content": "Mật mã khối là một kiểu mật mã trong đó bản rõ được xử lý theo khối và được sử dụng để tạo ra khối bản mã có chiều dài bằng chiều dài bản rõ. Thông thường, kích thước khối được sử dụng là 64 hoặc 128 bit. Cấu trúc bộ mật mã khối được mô tả như trong hình 2.3. Mật mã khối hoạt động trên khối bản rõ n bit để tạo ra khối bản mã n bit. Có 2^n khối bản rõ khác nhau có thể và, để việc mật mã hóa đó là biến đổi thuận nghịch (nghĩa là có thể giải mật mã), mỗi khối bản rõ phải tương ứng với một khối bản mã duy nhất. Sự biến đổi đó được gọi là biến đổi thuận nghịch, hoặc không phải một chiều.\nTrong trường hợp ánh xạ một chiều, bản mã 01 có thể được tạo ra từ một trong hai khối bản rõ. Như vậy nếu phép ánh xạ thuận nghịch được sử dụng, số phép biến đổi khác nhau là (2^n)! (vì đối với bản rõ đầu tiên sẽ có 2^n lựa chọn bản mã đầu ra, đối với bản rõ thứ 2 sẽ có (2^n)-1 lựa chọn bản mã còn lại,..).\nHình 2.4 mô tả nguyên lý của mật mã thay thế chung đối với n=4. Khối đầu vào 4 bit, là một trong 16 tổ hợp đầu vào, được ánh xạ bởi một mật mã thay thế để tạo ra một trong 16 tổ hợp đầu ra duy nhất. Nghĩa là, 4 bit bản rõ đầu vào sẽ được thay thế bởi 4 bit bản mã đầu ra tương ứng. Các ánh xạ mật mã hóa và giải mật mã có thể được định nghĩa bởi một bảng, như chỉ ra trong bảng 2.2. Đây là một dạng phổ biến nhất của mật mã khối và có thể được sử dụng để định nghĩa bất kỳ ánh xạ thuận nghịch nào giữa bản rõ và bản mã."
                },
                {
                  "level_4_title": "2.2.1.2. Cấu trúc mật mã khối Feistel",
                  "level_4_id": "2.2.1.2",
                  "content": "Cấu trúc mật mã khối Feistel do Horst Feistel đề xuất, là sự kết hợp của các phép thay thế và hoán vị. Trong mô hình mật mã Feistel, bản rõ sẽ được biến đổi qua một số vòng để cho ra bản mã cuối cùng. Mô hình mật mã khối Feistel được mô tả trong hình 2.5.\nCác phép biến đổi trong cấu trúc mật mã Feistel được mô tả như sau:\nP -> (LE0, RE0) -> (LE1, RE1) -> ... -> (LEn, REn) -> C\nTrong đó, P là bản rõ, Ci (i=1,2,...n) là các bản mã. Bản rõ và các bản mã được chia thành hai nửa trái và phải như sau:\nP = (LE0, RE0)\nCi = (LEi, REi), i=1,2,...n\nQua mỗi vòng, quy tắc biến đổi các nửa trái nửa phải như sau:\nLEi = RE(i-1)\nREi = LE(i-1) XOR F(RE(i-1), Ki)\nTrong đó, toán tử XOR thể hiện phép XOR, Ki là khóa con cho vòng thứ i. Khóa con này được tạo ra từ khóa K ban đầu theo một thuật toán sinh khóa con sao cho mỗi khóa con là khác nhau và khác khóa K. F là một hàm mật mã hóa giống nhau ở tất cả các vòng. Hàm F thể hiện phép thay thế, còn việc tráo đổi các nửa trái và nửa phải thể hiện phép hoán vị. Bản mã của hệ thống sẽ là bản mã đầu ra của vòng cuối cùng được hoán vị.\nC = (REn, LEn)\nQuá trình giải mật mã được thực hiện ngược lại cũng với số vòng như ở phần mật mã hóa. Khi đó, đầu vào bộ giải mật mã sẽ là bản mã C với giá trị như sau:\nLD0 = REn\nRD0 = LEn\nQua các vòng các bản mã được giải như sau:\nLDi = RD(i-1)\nRDi = LD(i-1) XOR F(RD(i-1), Ki)\nSau vòng cuối cùng, bản rõ được giải ra với giá trị như sau:\nP = (RDn, LDn)\nViệc hiện thực hóa chính xác hệ thống mật mã Feistel phụ thuộc vào việc lựa chọn các tham số và các đặc tính thiết kế dưới đây:\n+ Kích thước khối: kích thước khối lớn có nghĩa là an toàn cao hơn (với giả thiết là tất cả các tham số khác là như nhau) nhưng tốc độ mật mã hóa/giải mật mã bị giảm đối với một thuật toán cho trước. Thông thường, kích thước khối 64 bit là kích thước phổ biến, được sử dụng trong thiết kế mật mã khối. Tuy nhiên, hệ thống mật mã mới AES sử dụng kích thước khối 128 bit.\n+ Kích thước khóa: kích thước khóa lớn có nghĩa là an toàn cao hơn nhưng có thể làm giảm tốc độ mật mã hóa/giải mật mã. An toàn cao hơn có nghĩa là chống lại được các tấn công brute-force tốt hơn. Kích thước khóa 64 bit hoặc ít hơn 64 bit hiện nay đang được coi là không đủ, và khóa 128 bit đã trở thành một kích thước phổ biến.\n+ Số vòng: bản chất của mật mã Feistel là một vòng mật mã đơn không đủ để cung cấp tính an toàn nhưng nhiều vòng mật mã sẽ làm tăng tính an toàn. Kích thước phổ biến là 16 vòng.\n+ Thuật toán tạo khóa con: Tính phức tạp trong thuật toán này sẽ gây khó khăn cho kẻ tấn công.\n+ Hàm F: tương tự như thuật toán tạo khóa con, hàm F càng phức tạp thì độ an toàn càng cao."
                }
              ]
            },
            {
              "level_3_title": "2.2.2. DES",
              "level_3_id": "2.2.2",
              "content": "Mật mã tiêu chuẩn DES (Data Encryption Standard) được đưa ra năm 1977 bởi cục tiêu chuẩn quốc gia, giờ là Viện tiêu chuẩn và kĩ thuật quốc gia (NIST) Hoa Kỳ. Thuật toán của mật mã này được gọi là DEA (Data Encryption Algorithm). Với DEA, dữ liệu được mật mã hóa theo khối 64 bit sử dụng khóa 56 bit. Thuật toán này biến đổi 64 bit đầu vào trong một chuỗi các bước thành 64 bit đầu ra. DES ngày càng trở thành thuật toán mật mã đối xứng phổ biến, đặc biệt trong các ứng dụng tài chính.",
              "children": [
                {
                  "level_4_title": "2.2.2.1. Cấu trúc DES",
                  "level_4_id": "2.2.2.1",
                  "content": "Mật mã DES có các đặc điểm sau:\n+ Là mã thuộc mã Feistel có 16 vòng, ngoài ra DES có thêm một hoán vị khởi tạo trước khi bắt đầu vòng 1 và một hoán vị kết thúc sau vòng 16.\n+ Kích thước khối là 64 bit.\n+ Kích thước khóa là 56 bit\n+ Mỗi vòng của DES dùng khóa con có kích thước 48 bit được trích ra từ khóa chính.\nCấu trúc mật mã hóa của mã DES được mô tả như hình 2.7. Như chỉ ra ở nửa hình bên trái của hình 2.7, quá trình xử lý bản rõ diễn ra trong ba giai đoạn. Đầu tiên, bản rõ 64 bit được chuyển tới khối hoán vị khởi tạo để sắp xếp lại các bit và cho ra chuỗi bit đã được hoán vị. Tiếp theo đó là 16 vòng mật mã Feistel. Đầu ra của vòng cuối cùng (vòng 16) gồm 64 bit là một hàm của bản rõ đầu vào và khóa K. Sau đó, nửa trái và nửa phải của 64 bit này sẽ được tráo đổi cho nhau. Cuối cùng, các bit đã được tráo đổi đó được đưa qua bộ hoán vị kết thúc, đây là một hàm hoán vị nghịch đảo của hoán vị khởi tạo, và cho ra 64 bit bản mã.\nPhần bên phải của hình 2.7 mô tả cách thức khóa 56 bit được sử dụng. Ban đầu, khóa 64 bit được chuyển qua bộ hoán vị khóa. Sau đó, đối với mỗi 16 vòng, khóa con Ki được tạo ra bằng cách kết hợp dịch vòng trái và hoán vị. Hàm hoán vị là giống nhau ở mỗi vòng, nhưng khóa con khác nhau được tạo ra bởi các dịch vòng trái được lặp lại ở các bit khóa."
                },
                {
                  "level_4_title": "2.2.2.2. Hoán vị khởi tạo và hoán vị kết thúc",
                  "level_4_id": "2.2.2.2",
                  "content": "Giả sử bản rõ 64 bit được đánh số từ trái qua phải là 0, 1, 2, ..., 63 hay b0b1b2...b63, khi đó hoán vị khởi tạo sẽ hoán đổi các bit theo quy tắc sau:\n58 50 42 34 26 18 10 2\n60 52 44 36 28 20 12 4\n62 54 46 38 30 22 14 6\n64 56 48 40 32 24 16 8\n57 49 41 33 25 17 9 1\n59 51 43 35 27 19 11 3\n61 53 45 37 29 21 13 5\n63 55 47 39 31 23 15 7\n(b0b1b2...b63 -> b58b50...b7)\nHoán vị kết thúc hoán đổi các bit theo quy tắc sau:\n40 8 48 16 56 24 64 32\n39 7 47 15 55 23 63 31\n38 6 46 14 54 22 62 30\n37 5 45 13 53 21 61 29\n36 4 44 12 52 20 60 28\n35 3 43 11 51 19 59 27\n34 2 42 10 50 18 58 26\n33 1 41 9 49 17 57 25\nĐối với các kiểu tấn công biết bản rõ hay bản rõ được lựa chọn, hoán vị khởi tạo và hoán vị kết thúc không có ý nghĩa bảo mật, sự tồn tại của hai hoán vị trên được cho là do yếu tố lịch sử để lại."
                },
                {
                  "level_4_title": "2.2.2.3. Các vòng mật mã của DES",
                  "level_4_id": "2.2.2.3",
                  "content": "Hình 2.8 dưới đây minh họa một vòng Feistel của DES. Trong đó, hàm F được mô tả như sau:\nF(R(i-1), Ki) = P-box(S-boxes(Expand(R(i-1)) XOR Ki))\nTrong đó, hàm Expand(R(i-1)) mở rộng R(i-1) từ 32 bit thành 48 bit. Ngược lại, hàm S-boxes nén 48 bit thành 32 bit. Hàm P-box thực hiện hoán vị 32 bit. Cụ thể, hoạt động của các hàm này như sau:\n+ Hàm Expand(R(i-1)): đánh số các bit của R(i-1) theo thứ tự từ trái qua phải là 0, 1, 2,..., 31. Hàm này sẽ thực hiện vừa hoán vị vừa mở rộng 32 bit thành 48 bit theo quy tắc sau:\n32 1 2 3 4 5\n4 5 6 7 8 9\n8 9 10 11 12 13\n12 13 14 15 16 17\n16 17 18 19 20 21\n20 21 22 23 24 25\n24 25 26 27 28 29\n28 29 30 31 32 1\n+ Hàm S-boxes: biến đổi 48 bit thành 32 bit. S-boxes được chia thành 8 hàm S-box con, mỗi hàm biến đổi 6 bit thành 4 bit. Hàm S-box đầu tiên hoạt động như sau: b1b6 xác định hàng, b2b3b4b5 xác định cột.\n+ Hàm P-box: thực hiện hoán vị 32 bit đầu vào theo quy tắc:\n16 7 20 21\n29 12 28 17\n1 15 23 26\n5 18 31 10\n2 8 24 14\n32 27 3 9\n19 13 30 6\n22 11 4 25"
                },
                {
                  "level_4_title": "2.2.2.4. Thuật toán sinh khóa con của DES",
                  "level_4_id": "2.2.2.4",
                  "content": "Đầu tiên, khóa 64 bit được chuyển qua bộ hoán vị và nén thành khóa 56 bit theo quy tắc dưới đây:\n57 49 41 33 25 17 9\n1 58 50 42 34 26 18\n10 2 59 51 43 35 27\n19 11 3 60 52 44 36\n63 55 47 39 31 23 15\n7 62 54 46 38 30 22\n14 6 61 53 45 37 29\n21 13 5 28 20 12 4\nSau đó, khóa 56 bit đó được chia thành hai nửa trái KL và phải KR, mỗi nửa có kích thước 28 bit. Tại vòng thứ i (i=1,...,16), KLi-1 và KRi-1 được dịch vòng trái ri bit để tại ra hai nửa KLi và KRi với ri được xác định như sau:\nri = 1 nếu i thuộc {1,2,9,16}\nri = 2 nếu i không thuộc {1,2,9,16}\nCuối cùng, khóa Ki của vòng thứ i được tạo ra bằng cách hoán vị và nén 56 bit KLi và KRi thành 48 bit theo quy tắc sau:\n14 17 11 24 1 5\n3 28 15 6 21 10\n23 19 12 4 26 8\n16 7 27 20 13 2\n41 52 31 37 47 55\n30 40 51 45 33 48\n44 49 39 56 34 53\n46 42 50 36 29 32"
                },
                {
                  "level_4_title": "2.2.2.5. Hiệu ứng lan truyền",
                  "level_4_id": "2.2.2.5",
                  "content": "Một tính chất quan trọng cần thiết của mọi thuật toán mã hóa là chỉ cần một thay đổi nhỏ trong bản rõ hay trong khóa sẽ dẫn đến thay đổi lớn trong bản mã. Cụ thể, chỉ cần thay đổi một bit trong bản rõ hay khóa thì dẫn đến sự thay đổi của nhiều bit bản mã. Tính chất này được gọi là hiệu ứng lan truyền. Nhờ có tính chất này mà kẻ phá mã không thể giới hạn miền tìm kiếm của bản rõ hay của khóa (dù phá mã theo known-plaintext hay chosen-plaintext) nên phải thực hiện kiểu tấn công Brute Force (vét cạn khóa). DES là một phương pháp mã hóa có hiệu ứng lan truyền này."
                }
              ]
            },
            {
              "level_3_title": "2.2.3. Nguyên lí thiết kế mật mã khối",
              "level_3_id": "2.2.3",
              "content": "Mặc dù đã có rất nhiều nghiên cứu để nâng cao tính an toàn trong việc thiết kế mật mã khối, nhưng các nguyên lý cơ bản vẫn không thay đổi nhiều so với hoạt động của mã Feistel và DES từ những năm 1970. Trong mục này, ba khía cạnh cốt lõi trong việc thiết kế mật mã khối được trình bày, gồm số vòng tạo mã, thiết kế hàm F, và thuật toán tạo khóa.\n\n**Số vòng tạo mã:**\nTính an toàn mật mã của mật mã Feistel xuất phát từ ba khía cạnh của việc thiết kế đó là số vòng tạo mã, hàm F, và thuật toán tạo khóa. Số vòng tạo mã càng lớn thì càng gây khó khăn cho kẻ tấn công, thậm chí trong cả trường hợp hàm F tương đối yếu. Nhìn chung, số vòng tạo mã nên được chọn sao cho độ khó tấn công phức tạp hơn kiểu tấn công tìm khóa brute-force. Tiêu chí này vẫn được sử dụng trong việc thiết kế DES. Đối với mật mã DES sử dụng 16 vòng mã hóa, tấn công mật mã yêu cầu 2^55.1 hành động, trong khi kiểu tấn công brute force yêu cầu 2^55 hành động. Như vậy, nếu DES có 15 hoặc ít hơn 15 vòng tạo mã, số hành động yêu cầu để phá mã sẽ nhỏ hơn số hành động yêu cầu phá mã theo kiểu brute-force. Tiêu chí này được quan tâm rất nhiều bởi vì nó có thể dễ dàng điều chỉnh tính an toàn của thuật toán và so sánh với các thuật toán khác.\n\n**Thiết kế hàm F**\nThành phần quan trọng nhất của mật mã khối Feistel là hàm F. Hàm F có chức năng cung cấp sự hỗn loạn trong mật mã Feistel, do đó nó phải là khó có thể khôi phục lại phép thay thế được thực hiện bởi hàm F đó. Một tiêu chí rõ ràng nhất đối với hàm F đó là tính phi tuyến. Hàm F càng phi tuyến, thì càng gây khó khăn cho kẻ tấn công. Có một số tiêu chí khác được xem xét khi thiết kế hàm F. Trong đó, các thuật toán phải có hiệu ứng lan truyền tốt. Điều này có nghĩa là, khi thay đổi 1 bit đầu vào thì sẽ làm thay đổi nhiều bit ở đầu ra. Tiêu chí lan truyền nghiêm ngặt (SAC) được phát biểu rằng bất kỳ bit đầu ra j nào của S-box sẽ thay đổi với xác xuất bằng 0.5 khi bất kỳ một bit đầu vào i nào bị thay đổi với mọi i và j. Mặc dù SAC chỉ mô tả với S-box, tiêu chí tương tự cũng được áp dụng với hàm F. Một tiêu chí khác đó là tiêu chí độc lập bit (BIC) phát biểu rằng các bit đầu ra j và k sẽ thay đổi một cách độc lập khi bất kỳ một bit đầu vào i nào bị thay đổi với mọi i, j, và k.\n\n**Thuật toán tạo khóa:**\nVới bất kỳ mật mã khối Feistel nào, một khóa chính sẽ được sử dụng để tạo ra một khóa con cho mỗi vòng tạo mã. Thông thường, các khóa con sẽ được lựa chọn để hạn chế tối đa được việc suy diễn ra các khóa con và việc khôi phục khóa chính. Thuật toán tạo khóa nên đảm bảo được hai tiêu chí SAC và BIC.",
              "children": []
            }
          ]
        },
        {
          "level_2_title": "2.3. Tiêu chuẩn mật mã hóa tiên tiến AES",
          "level_2_id": "2.3",
          "content": "Vào những năm 1990, nhận thấy nguy cơ của mật mã hóa DES là kích thước khóa ngắn, có thể bị phá mã trong tương lai gần, Cục tiêu chuẩn quốc gia Hoa Kỳ đã kêu gọi xây dựng một phương pháp mật mã hóa mới. Cuối cùng một thuật toán có tên là Rijndael được chọn và đổi tên thành Andvanced Encryption Standard hay AES được công bố bởi NIST, Hoa Kỳ vào năm 2001. Giống như DES, mật mã hóa AES là một mật mã khối đối xứng gồm nhiều vòng. Khác với DES, mã hóa AES không phải là một mã hóa Feistel.",
          "children": [
            {
              "level_3_title": "2.3.1. Cấu trúc AES",
              "level_3_id": "2.3.1",
              "content": "Hình 2.9 đưa ra cấu trúc chung của quá trình mật mã hóa AES. Kích thước khối bản rõ được sử dụng là 128 bit, hay 16 byte. Độ dài khóa có thể là 16, 24, hoặc 32 byte (128, 192, hoặc 256 bit). Thuật toán được sử dụng như là AES-128, AES-192, hay AES-256, phụ thuộc vào độ dài khóa.\nĐầu vào của các thuật toán mật mã hóa và giải mật mã là khối 128 bit. Khối này được sắp xếp thành ma trận vuông có kích thước 4x4 byte, được sửa đổi tạo mỗi giai đoạn mật mã hóa hoặc giải mật mã. Sau giai đoạn cuối cùng, đầu ra cũng sẽ là ma trận vuông có kích thước 4x4 byte. Tương tự như vậy, khóa M byte cũng được sắp xếp thành ma trận vuông, sau đó được đưa tới bộ mở rộng khóa để tạo thành mảng các từ khóa.\nHình 2.10 mô tả việc mở rộng khóa 128 bit. Mỗi từ khóa gồm 4 byte, và toàn bộ mảng khóa là 44 từ cho khóa 128 bit. Chú ý rằng thứ tự theo byte trong ma trận được sắp xếp theo cột. Ví dụ, bốn byte đầu của đầu vào bản rõ 128 bit nằm ở cột thứ nhất của ma trận, bốn byte tiếp theo nằm ở cột thứ 2,.... Tương tự, bốn byte đầu tiên của khóa được mở rộng, từ khóa, nằm ở cột đầu tiên của ma trận w.\nHệ mật mã bao gồm N vòng, trong đó số vòng phụ thuộc vào độ dài khóa: 10 vòng cho khóa 16 byte, 12 vòng cho khóa 24 byte, và 14 vòng cho khóa 32 byte. N-1 vòng đầu bao gồm bốn hàm biến đổi: SubBytes, ShiftRows, MixColumns, và AddRoundKey. Vòng cuối cùng chỉ bao gồm 3 phép biến đổi, và có một phép biến đổi khởi tạo (AddRoundKey) trước vòng đầu tiên, có thể coi đó là vòng số 0. Mỗi phép biến đổi lấy 1 hoặc nhiều ma trận 4x4 làm đầu vào và tạo ra đầu ra cũng là ma trận 4x4. Như chỉ ra trong hình 2.9, đầu ra mỗi vòng là một ma trận 4x4, với đầu ra của vòng cuối cùng sẽ là bản mã.\nHàm mở rộng khóa tạo ra N+1 khóa cho các vòng, mỗi khóa là một ma trận 4x4. Khóa mỗi vòng là một trong những đầu vào của biến đổi AddRoundKey của mỗi vòng.\nHình 2.11 đưa ra sơ đồ mật mã AES một cách chi tiết hơn, chỉ rõ thứ tự các phép biến đổi trong mỗi vòng và chỉ ra hàm giải mật mã tương ứng.\nSơ đồ mật mã gồm 10 vòng, mỗi vòng mật mã AES được thực hiện như trong hình 2.12. Trong mỗi vòng mật mã, một phép hoán vị và ba phép thay thế được sử dụng:\n+ Substitute bytes: sử dụng S-box để thực hiện thay thế các byte của khối đầu vào\n+ ShiftRows: đây là phép hoán vị đơn giản\n+ MixColumns: tại khối này phép thay thế khác được sử dụng\n+ AddRoundKey: khối này thực hiện phép XOR của của khối mật mã đầuvào và một phần khóa mở rộng.\nCác hàm biến đổi này có thể dễ dàng được khôi phục. Đối với các hàm SubBytes, ShiftRows, và MixColumns, một hàm nghịch đảo được sử dụng để giải mật mã. Đối với hàm AddRoundKey, giải mật mã có thể thực hiện bằng cách thực hiện phép XOR giữa từ mã đó với chính khóa sử dụng, do A XOR B XOR B = A",
              "children": []
            },
            {
              "level_3_title": "2.3.2. Các hàm biến đổi AES",
              "level_3_id": "2.3.2",
              "children": [
                {
                  "level_4_title": "2.3.2.1. Hàm SubBytes",
                  "level_4_id": "2.3.2.1",
                  "content": "Hàm biến đổi này chỉ đơn giản là phép thay thế, như trong hình 2.13. AES định nghĩa ma trận byte có kích thước 16x16 được gọi là S-box. S-box chứa toàn bộ 256 giá trị có thể của các byte. Mỗi byte đầu vào của khối S-box được ánh xạ thành một byte mới theo cách sau: 4 bit bên trái của byte đầu vào được xem như là giá trị hàng và 4 bit bên phải phải được xem như là giá trị cột. Các giá trị cột và hàng đó được coi là các chỉ số cột và hàng trong S-box để lựa chọn giá trị đầu ra 8 bit duy nhất. Ví dụ, giá trị theo mã hexa {95} tương ứng với hàng 9 và cột 5 của S-box, chứa giá trị {2A}. Như vậy, giá trị {95} được ánh xạ thành giá trị {2A}."
                },
                {
                  "level_4_title": "2.3.2.2. Hàm ShiftRows",
                  "level_4_id": "2.3.2.2",
                  "content": "Hàm ShiftRows thực hiện biến đổi dịch vòng các hàng của ma trận đầu vào, như chỉ ra trong hình 2.17. Như chỉ ra trong hình 2.17, hàng đầu tiên của ma trận đầu vào không bị dịch, trong khi hàng thứ 2, các byte được dịch vòng trái 1 byte. Đối với hàng thứ 3, dịch vòng trái 2 byte được thực hiện, và với hàng cuối cùng, dịch vòng trái 3 byte được thực hiện.\nHàm ShiftRows ngược, để thực hiện giải mật mã được gọi là InvShiftRows, thực hiện dịch vòng theo hướng ngược lại cho mỗi ba hàng cuối."
                },
                {
                  "level_4_title": "2.3.2.3. Hàm MixColumns",
                  "level_4_id": "2.3.2.3",
                  "content": "Hàm MixColumns thực hiện biến đổi trộn các cột của ma trận đầu vào, được thực hiện trên mỗi cột một cách riêng biệt, như chỉ ra trong hình 2.19. Mỗi byte của một cột được ánh xạ thành một giá trị mới là một hàm của bốn byte trong cột đó. Phép biến đổi này có thể được định nghĩa bởi phép nhân ma trận sau:\n[s'0,c s'1,c s'2,c s'3,c]T = [02 03 01 01; 01 02 03 01; 01 01 02 03; 03 01 01 02] * [s0,c s1,c s2,c s3,c]T\nNhư vậy mỗi cột đầu ra được biến đổi theo cột đầu vào tương ứng như sau:\ns'0,j = (2*s0,j) XOR (3*s1,j) XOR s2,j XOR s3,j\ns'1,j = s0,j XOR (2*s1,j) XOR (3*s2,j) XOR s3,j\ns'2,j = s0,j XOR s1,j XOR (2*s2,j) XOR (3*s3,j)\ns'3,j = (3*s0,j) XOR s1,j XOR s2,j XOR (2*s3,j)\nHàm biến đổi ngược của hàm MixColumns là hàm InvMixColumns, được định nghĩa bởi phép nhân ma trận với ma trận nghịch đảo."
                },
                {
                  "level_4_title": "2.3.2.4. Hàm AddRoundKey",
                  "level_4_id": "2.3.2.4",
                  "content": "Hàm AddRoundKey thực hiện phép XOR giữa 128 bit đầu vào và 128 bit khóa của vòng đó, được mô tả trong hình 2.20."
                }
              ]
            },
            {
              "level_3_title": "2.3.3. Tạo khóa AES",
              "level_3_id": "2.3.3",
              "content": "Thuật toán mở rộng khóa AES với đầu vào gồm 4 từ hay 16 byte (hình 2.11) tạo ra đầu ra gồm một mảng tuyến tính 44 từ (176 byte). Đầu ra của bộ mở rộng khóa đủ để cung cấp khóa cho các vòng mật mã. Khóa được đưa ra bốn từ đầu tiên của khóa mở rộng. Phần còn lại của khóa mở rộng được điền vào 4 từ tại mỗi thời điểm. Mỗi từ được thêm vào w[i] phụ thuộc vào từ ngay trước nó, w[i-1], và w[i-4].\nThuật toán tạo khóa mở rộng như sau:\nKeyExpansion (byte key [16], word w[44])\n{\nword temp\nFor (i=0; i<4; i++) w[i] = (key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]);\nFor (i=4; i<44; i++)\n{\ntemp = w[i-1];\nIf (i mod 4 = 0) temp = SubWord (RotWord (temp)) XOR Rcon[i/4];\nw[i] = w[i-4] XOR temp\n}\n}\nHình 2.21 dưới đây mô tả thuật toán tạo khóa AES, and hàm phức g. Hàm phức g gồm các hàm con dưới đây:\n+ RotWord: dịch vòng trái một byte. Giả sử từ đầu vào có 4 byte là [B0, B1, B2, B3] thì kết quả của RotWord là [B1, B2, B3, B0].\n+ SubWord: thay thế mỗi byte trong từ đầu vào bằng cách tra cứu bảng S-box trong thao tác SubBytes.\n+ Kết quả của việc thực hiện hai hàm trên sẽ được thực hiện XOR với hàm Rcon[j].\nHàm Rcon[j] cho mỗi vòng là khác nhau, và được định nghĩa như sau Rcon[j]=(RC[j],0,0,0), với RC[j] được xác định."
            },
            {
              "level_3_title": "2.3.4. Thực hiện AES",
              "level_3_id": "2.3.4",
              "content": "Như đã đề cập ở trên, việc giải mật mã AES không hoàn toàn giống như quá trình mật mã hóa. Nghĩa là, trình tự các phép biến đổi cho việc giải mật mã khác với trình tự các phép biến đổi cho việc mật mã hóa, mặc dù các sơ đồ tạo khóa cho quá trình mật mã hóa và giải mật mã là giống nhau. Đây là một nhược điểm mà do đó hai module phần mềm và phần firmware riêng biệt cần được yêu cầu cho các ứng dụng mật mã hóa và giải mật mã. Tuy nhiên, có một phiên bản tương đương của thuật toán giải mật mã mà có cấu trúc giống như cấu trúc của thuật toán mật mã hóa. Phiên bản tương đương này có trình tự các phép biến đổi như nhau cho cả quá trình mật mã hóa và giải mật mã. Để đạt được điều này, sơ đồ tạo khóa cần có sự thay đổi.\nNhư chỉ ra trong hình 2.11, mỗi vòng mật mã hóa có các hàm SubBytes, ShiftRows, MixColumns, AddRoundKey. Mỗi vòng giải mật mã chuẩn có các hàm InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns. Do đó, hai giai đoạn đầu tiên của vòng giải mật mã cần được thay đổi, và hai giai đoạn sau cũng cần được thay đổi.\nThay đổi hàm InvShiftRows và InvSubBytes: hàm InvShiftRows ảnh hưởng đến thứ tự byte trong ma trận nhưng không làm thay đổi nội dung các byte và không phụ thuộc vào nội dung để thực hiện phép biến đổi. Hàm InvSubBytes ảnh hưởng đến nội dung của các byte trong ma trận nhưng không làm thay đổi thứ tự byte và không phụ thuộc vào thứ tự byte để thực hiện phép biến đổi. Do đó, hai phép toán này có thể được thay thế lẫn nhau như sau:\nInvShiftRows [InvSubBytes(Si)] = InvSubBytes [InvShiftRows(Si)]\nThay đổi hàm AddRoundKey, InvMixColumns: các phép biến đổi AddRoundKey, InvMixColumns không làm thay đổi thứ tự các byte trong ma trận. Nếu coi khóa là một chuỗi các từ, thì cả hai hàm AddRoundKey và InvMixColumns hoạt động trên một cột của ma trận tại một thời điểm. Hai hoạt động đó là tuyến tính đối với đầu vào là cột. Nghĩa là, với ma trận cho trước Si và khóa cho trước wj, thì:\nInvMixColumns (Si XOR wj) = [InvMixColumns (Si)] XOR [InvMixColumns (wj)]\nTừ đó, ta thấy rằng có thể tráo đổi vị trí các hàm AddRoundKey và InvMixColumns, miễn là đầu tiên phải thực hiện hàm InvMixColumns đối với khóa mỗi vòng. Chú ý rằng, không cần phải thực hiện hàm InvMixColumns với khóa cho đầu vào của hàm biến đổi AddRoundKey đầu tiên (vòng 0) hay hàm biến đổi AddRoundKey của vòng cuối cùng (vòng 10). Bởi vì hai phép biến đổi AddRoundKey này không cần tráo đổi với hàm InvMixColumns để tạo ta thuật toán giải mật mã tương đương.\n\n**Các khía cạnh thực thi:**\nĐể thực hiện hiệu quả mật mã hóa AES trên các bộ xử lý 8 bit của các card thông minh hiện tại, và trên các bộ xử lý 32 bit của các máy tính, một số yêu cầu sau phải được đáp ứng.\nĐối với bộ xử lý 8 bit: AES cần được thực hiện một cách rất hiệu quả trên các bộ xử lý 8 bit. Hàm AddRoundKey là một phép XOR theo byte. Hàm ShiftRows chỉ là phép dịch byte đơn giản. Hàm SubBytes thực hiện tại mức byte và chỉ yêu cầu bảng 256 byte. Hàm MixColumns thực hiện nhân ma trận.\nĐối với bộ xử lý 32 bit: Việc thực hiện được mô tả trong các mục trước chỉ sử dụng cho các phép tính toán 8 bit. Đối với bộ xử lý 32 bit, việc thực hiện hiệu quả hơn có thể đạt được nếu các phép tính toán được định nghĩa trên các từ 32 bit. Khi đó, các phép biến đối có thể được mô tả như sau, trong đó giả thiết ma trận đầu vào gồm các phần tử ai,j và ma trận khóa gồm các phần tử ki,j.\nNhận thấy rằng, việc thực hiện AES chỉ dựa vào việc tra 4 bảng và thực hiện các 4 phép XOR trên mỗi cột cho mỗi vòng, cộng với 4 Kbyte để lưu trữ bảng.",
              "children": []
            }
          ]
        },
        {
          "level_2_title": "2.4. Các ứng dụng của mật mã khối",
          "level_2_id": "2.4",

          "children": [
            {
              "level_3_title": "2.4.1. Mật mã hóa nhiều lần",
              "level_3_id": "2.4.1",
              "content": "Đối mặt với nguy cơ tấn công brute-force của mật mã DES, đã có rất nhiều hướng quan tâm trong việc tìm ra phương pháp thay thế. Một cách tiếp cận là thiết kế một thuật toán mới hoàn toàn, AES là một ví dụ. Một cách khác có thể bảo tồn được các đầu tư trước đó về phần cứng cũng như phần mềm đó là sử dụng mật mã hóa nhiều lần với DES và sử dụng nhiều khóa.\n\n**DES hai lần (Double DES)**\nDạng đơn giản nhất của mật mã hóa nhiều lần có hai giai đoạn mật mã hóa và sử dụng hai khóa như hình 2.24. Với bản rõ P và hai khóa mật mã K1 và K2, bản mã C được tạo ra như sau:\nC = E(K2, E(K1, P))\nGiải mật mã yêu cầu biết các khóa đó và được thực hiện ngược lại như sau:\nP = D(K1, D(K2, C))\nĐiều này giống như là Double DES dùng một khóa có kích thước là 112 byte, chỉ có một hạn chế là tốc độ chậm hơn DES vì phải dùng DES hai lần. Tuy nhiên người ta đã tìm được một phương pháp tấn công Double DES có tên gọi là gặp-nhau-ở-giữa (meet-in-themiddle). Đây là một phương pháp tấn công chosen-plaintext. Phương pháp tấn công này có thể được hiểu như sau. Như chỉ ra trong hình 2.24 a,\nX = E(K1, P)\nX = D(K2, C)\nNếu biết trước một cặp (P,C), kẻ tấn công sẽ thực hiện như sau. Đầu tiên mật mã hóa P với 2^56 giá trị có thể của khóa K1. Lưu các kết quả đó trong 1 bảng. Tiếp theo, giải mật mã C sử dụng 2^56 giá trị có thể của khóa K2. Với mỗi kết quả giải mật mã, so sánh với kết quả trong bảng. Nếu có giá trị nào giống nhau, thử lại hai khóa được tìm ra đó với cặp (P,C) đã biết mới. Nếu hai khóa đó cho ra bản mã đúng, hai khóa đó được coi là hai khóa đúng.\n\n**Triple DES**\nĐể khắc phục được sự tấn công của Double DES, DES ba lần với ba khóa khác nhau được lựa chọn. Chiều dài khóa là 168 bít sẽ gây phức tạp hơn nhiều cho việc phá mã bằng phương pháp tấn công gặp-nhau-ở-giữa. Triple DES được mô tả như hình 2.24b.\nBản mã được xác định như sau:\nC = E(K3, D(K2, E(K1, P)))\nTrong thực tế người ta chỉ dùng Triple DES với hai khóa K1, K2 mà vẫn đảm bảo độ an toàn cần thiết. Khi đó, bản mã và bản rõ được xác định bởi.\nC = E(K1, D(K2, E(K1, P)))\nP = D(K1, E(K2, D(K1, C)))"
            },
            {
              "level_3_title": "2.4.2. Các chế độ và ứng dụng mật mã khối",
              "level_3_id": "2.4.2",
              "content": "Mật mã khối được áp dụng để mật mã hóa một khối dữ liệu có kích thước xác định. Để mật mã hóa một bản tin dài, bản tin được chia ra thành nhiều khối và áp dụng mật mã khối cho từng khối một. Có nhiều mô hình ứng dụng mật mã khối như ECB, CBC, CTR, OFB và CFB.\n\n**Chế độ ECB (Electronic Codebook)**\nTrong mô hình ECB, mỗi khối được mật mã hóa một cách riêng rẽ, dùng chung một khóa K. Mô hình mật mã hóa và giải mật mã của ECB được mô tả trong hình 2.25. Đặc điểm nổi bật của mô hình ECB là nếu như bản rõ giống nhau thì bản mã giống nhau. Với mô hình đơn giản của ECB, kẻ tấn công có thể dựa vào một số đặc tính thống kê của dữ liệu để tiến hành phá mã. ECB chỉ thích hợp để mật mã hóa cho các bản tin có kích thước ngắn, ví dụ như mật mã hóa cho khóa, Do đó, nếu muốn truyền khóa DES hoặc AES một cách an toàn, ECB là một phương pháp thích hợp để truyền khóa đó. Với các bản tin dài hơn, ECB có thể không an toàn.\n\n**Chế độ CBC (Cipher Block Chaining)**\nĐể khắc phục được nhược điểm an toàn của chế độ ECB, chế độ CBC được đưa ra với mục đích là tạo ra các khối bản mã khác nhau khi đầu vào là các bản rõ giống nhau. Hình 2.26 mô tả mô hình CBC đó. Trong sơ đồ mật mã hóa CBC, đầu vào của mỗi khối mật mã hóa là kết quả của phép XOR giữa bản rõ hiện tại và bản mã trước đó, sử dụng cùng một khóa cho mỗi khối.\nCi = E(Pi XOR Ci-1, K) với i = 1, 2, ..., N\nDo đó để mã hóa khối đầu tiên, người ta dùng một khối dữ liệu giả được gọi là vector khởi tạo (initialization vector – IV) và được chọn ngẫu nhiên:\nC1 = E(P1 XOR IV, K)\nQuá trình giải mật mã được thực hiện ngược lại.\nP1 = D(C1, K) XOR IV\nPi = D(Ci, K) XOR Ci-1 với i = 1, 2, ..., N\nBêm mật mã hóa và bên giải mật mã phải dùng chung vector khởi tạo IV. Vector khởi tạo không cần giữ bí mật nên thường được gắn vào trước bản mã trước khi truyền thông điệp (IV C1 C2 ... CN). Có thể thấy rằng nội dung của bản mã Ci không chỉ phụ thuộc vào bản rõ Pi mà còn phụ thuộc vào tất cả các bản rõ đứng trước và IV. Do đó nếu có hai bản rõ giống nhau thì hai bản mã sẽ không giống nhau (do IV ngẫu nhiên). Điều này khắc phục được hạn chế của mô hình ECB, từ bản mã kẻ tấn công không thể phát hiện ra những đặc tính thống kê của dữ liệu. Ngược lại, đối với việc giải mật mã, bản rõ Pi không chỉ phụ thuộc vào bản mã Ci mà còn phụ thuộc vào bản mã Ci-1 đứng trước. Do đó nếu xảy lỗi trên đường truyền, chỉ cần một bit bị hỏng thì dẫn đến không thể giải mật mã được bản mã đó và bản mã tiếp theo sau.\n\n**Chế độ CFB (Cipher Feedback)**\nĐối với AES, DES, hay bất cứ mật mã khối nào, việc mật mã hóa được thực hiện trên mỗi khối b bit. Trong trường hợp DES, b = 64 bit và trong AES, b = 128 bit. Tuy nhiên, có thể biến đổi từ mật mã khối thành mật mã dòng, sử dụng một trong ba chế độ gồm CFB, OFB và CTR. Mật mã dòng loại bỏ được các bit đệm vào bản tin để được số nguyên các khối. Nó có thể hoạt động theo thời gian thực. Do đó, nếu dòng ký tự đang được truyền đi, mỗi ký tự có thể được mật mã hóa và truyền đi ngay lập tức nhờ sử dụng mật mã dòng hướng ký tự.\nMột đặc tính mong muốn của mật mã dòng là bản mã có cùng độ dài với bản rõ. Do đó, nếu các ký tự 8 bit được truyền đi, mỗi ký tự sẽ được mật mã hóa để tạo ra bản mã 8 bit đầu ra. Nếu nhiều hơn 8 bit được tạo ra, dung lượng truyền dẫn sẽ bị lãng phí.\nHình 2.27 mô tả sơ đồ CFB. Giả thiết đơn vị truyền dẫn là s bit, thường s = 8. Trong sơ đồ này, bản rõ được chia thành các đoạn s bit. Trong quá trình mật mã hóa, đầu vào của khối chức năng mật mã hóa là thanh ghi dịch b bit được thiết lập khởi tạo bởi một vector khởi tạo (IV). S bit bên trái của khối mật mã hóa được thực hiện XOR với phần bản rõ đầu tiên P1 để tạo ra đoạn bản mã C1 đầu tiên. Nội dung của thanh ghi dịch được dịch trái s bit, và C1 được đặt vào s bit bên phải của thanh ghi dịch. Quá trình tiếp tục cho đến khi tất cả các đoạn bản rõ được mật mã hóa.\nĐối với quá trình giải mật mã, sơ đồ thực hiện cũng tương tự, ngoại trừ đoạn bản mã nhận được được thực hiện XOR với đầu ra của khối mật mã hóa để tạo ra đoạn bản rõ. Chú ý rằng, ở đây khối mật mã hóa được sử dụng chứ không phải khối giải mật mã được sử dụng. Điều này được giải thích cụ thể như sau. Gọi MSBs(X) là s bit có ý nghĩa nhất (các bit bên trái) của X. Ta có,\nC1 = P1 XOR MSBs[E(K, IV)]\nDo đó, P1 = C1 XOR MSBs[E(K, IV)]\n\n**Chế độ OFB (Output Feedback)**\nChế độ OFB tương tự như CFB. Đầu ra của khối mật mã hóa được đưa ngược lại thành đầu vào để mật mã hóa khối bản rõ tiếp theo (hình 2.28). Trong chế độ OFB, đơn vị khối bản rõ và bản mã có kích thước bất kỳ. Mật mã hóa OFB được mô tả như sau:\nCj = Pj XOR E(K, Oj-1)\nTrong đó, Oj-1 = E(K, Oj-2).\nMột ưu điểm của chế độ OFB là các lỗi bit trong quá trình truyền dẫn không bị truyền đi. Ví dụ, nếu lỗi bit xảy ra tại C1, chỉ có giá trị bản rõ khôi phục P1 bị ảnh hưởng; các đoạn bản rõ tiếp theo không bị ảnh hưởng. Tuy nhiên, nó có nhược điểm là dễ bị tấn công hơn CFB.\n\n**Chế độ CTR (counter)**\nHình 2.29 mô tả sơ đồ khối của CTR. Một Counter có kích thước bằng kích thước của khối bản rõ được sử dụng. Giá trị của counter phải khác với mỗi khối bản rõ được mật mã hóa. Cụ thể, counter được khởi tạo tại một giá trị nào đó, sau đó được tăng lên 1 cho các khối tiếp theo. Đối với quá trình mật mã hóa, counter được mật mã hóa và được thực hiện XOR với bản rõ để tạo ta khối bản mã. Đối với quá trình giải mật mã, mỗi counter được mật mã hóa được thực hiện XOR với bản mã để khôi phục khối bản rõ tương ứng.\nVới các counter lần lượt là T1, T2,..., Tn, chế độ CTR được định nghĩa như sau:\nCj = Pj XOR E(K, Tj) với j=1,...,N-1\nCN* = PN* XOR MSBu[E(K, TN)]\nPj = Cj XOR E(K, Tj) với j=1,...,N-1\nPN* = CN* XOR MSBu[E(K, TN)]\nĐối với khối bản rõ cuối cùng (có thể chỉ có u bit), chỉ u bit có ý nghĩa nhất (bên trái) của khối mật mã cuối cùng được sử dụng cho phép XOR cùng khối bản rõ đó."
            }
          ]
        },
        {
          "level_2_title": "2.5. Tạo số giả ngẫu nhiên và mật mã dòng",
          "level_2_id": "2.5",
          "children": [
            {
              "level_3_title": "2.5.1. Nguyên lí tạo số giả ngẫu nhiên",
              "level_3_id": "2.5.1",
              "content": "Số ngẫu nhiên đóng vai trò quan trọng trong việc sử dụng mật mã hóa cho các ứng dụng, các giao thức, và các thuật toán an toàn mạng khác nhau như trong các sơ đồ phân phối khóa và nhận thực lẫn nhau, tạo khóa phiên, tạo các khóa cho thuật toán mật mã khóa công khai RSA, hay tạo luồng bit cho mật mã dòng đối xứng.\nCó hai tiêu chí được sử dụng để đánh giá tính ngẫu nhiên của chuỗi ngẫu nhiên, đó là:\n+ Phân phối đồng nhất: phân phối các bit trong chuỗi phải là đồng nhất; nghĩa là tần suất xuất hiện của các bit 0 và 1 phải là như nhau.\n+ Độc lập: không chuỗi con nào trong chuỗi ngẫu nhiên đó có thể được suy ra từ các chuỗi con khác.\nTrong các ứng dụng như nhận thực lẫn nhau, tạo khóa phiên, và mật mã dòng, tính không thể dự đoán trước được yêu cầu. Yêu cầu này không chỉ là chuỗi số đó là ngẫu nhiên thống kê mà các thành phần kế tiếp trong chuỗi đó còn phải là không dự đoán trước được. Với các chuỗi ngẫu nhiên “đúng”, mỗi số là độc lập thống kê với các số khác trong chuỗi đó và vì vậy là không thể dự đoán trước được. Mặc dù, các số ngẫu nhiên đúng được sử dụng trong một số ứng dụng, chúng có một số hạn chế như tính không hiệu quả. Do vậy, việc sử dụng các thuật toán để tạo các chuỗi số ngẫu nhiên là hiệu quả hơn.\nCác ứng dụng mật mã hóa thường tận dụng các kỹ thuật thuật toán cho việc tạo số ngẫu nhiên. Các thuật toán này là xác định và vì vậy tạo ra các chuỗi số không phải là ngẫu nhiên thống kê. Tuy nhiên, nếu thuật toán tốt, chuỗi số kết quả sẽ qua được nhiều bài kiểm tra về tính ngẫu nhiên. Các số như vậy được gọi là các số giả ngẫu nhiên.\nHình 2.30 mô tả bộ tạo số ngẫu nhiên đúng (TRNG) với hai bộ tạo số giả ngẫu nhiên. TRNG có đầu vào là một nguồn thực sự ngẫu nhiên; nguồn này thường được đề cập đến là nguồn entropy (entropy source). Nguồn entropy được lấy ra từ môi trường vật lý của máy tính và có thể tính đến cả các mẫu định thời bấm phím, hoạt động của ổ đĩa, sự di chuyển chuột, và các giá trị tức thời của đồng hồ hệ thống. Một nguồn, hoặc sự kết hợp của các nguồn, được coi là đầu vào của thuật toán để tạo ra đầu ra là chuỗi nhị phân ngẫu nhiên. TRNG có thể chỉ đơn giản là phép biến đổi các nguồn tương tự thành đầu ra nhị phân.\nNgược lại, PRNG có đầu vào là một giá trị cố định, được gọi là hạt giống (seed), và tạo ra chuỗi bit đầu ra sử dụng một thuật toán xác định. Thường thì seed được tạo ra bởi một bộ TRNG. Như chỉ ra trong hình 2.30, một số kết quả của thuật toán được phản hồi lại như là đầu vào của thuật toán bằng một đường hồi tiếp. Chú ý rằng, dòng bit đầu ra được xác định chỉ bởi một hoặc nhiều giá trị đầu vào, do đó kẻ tấn công mà biết thuật toán và seed thì có thể tạo lại toàn bộ dòng bit.\nHình 2.30 đưa ra hai bộ tạo chuỗi giả ngẫu nhiên khác nhau:\n+ Bộ tạo số giả ngẫu nhiên: thuật toán được sử dụng để tạo ra chuỗi bit kết thúc mở được gọi là PRNG. Ứng dụng phổ biến cho chuỗi bit này là đầu vào của mật mã dòng đối xứng.\n+ Hàm giả ngẫu nhiên (PRF): PRF được sử dụng để tạo ra chuỗi bit giả ngẫu nhiên có độ dài cố định. PRF cũng có đầu vào là seed và một thông tin khác như là ID người sử dụng hay ID ứng dụng."
            },
            {
              "level_3_title": "2.5.2. Bộ tạo số giả ngẫu nhiên",
              "level_3_id": "2.5.2",
              "content": "Trong phần này, hai kiểu thuật toán cho bộ PRNG được trình bày.\n\n**Các bộ tạo đồng dạng tuyến tính (Linear Congruential)**\nKỹ thuật được sử dụng rộng rãi cho việc tạo số giả ngẫu nhiên là thuật toán đồng dạng. Thuật toán này có 4 tham số như sau:\nm: the modulus, m>0\na: the multiplier, 0<a<m\nc: the increment, 0<=c<m\nX0: the starting value, or seed, 0<=X0<m\nChuỗi số ngẫu nhiên {Xn} được tính như sau: X(n+1) = (aXn + c) mod m\nNếu m, a, c, và X0 là số nguyên, kĩ thuật này sẽ tạo ra chuỗi số nguyên với mỗi số nguyên nằm trong dải 0 <= Xn < m.\nViệc lựa chọn các giá trị cho a, c, và m là vấn đề then chốt trong việc phát triển một bộ tạo số ngẫu nhiên tốt. Nếu m là một số rất lớn, có khả năng tạo ra một chuỗi dài các số ngẫu nhiên khác nhau. Tiêu chí chung đó là m gần với số nguyên không âm lớn nhất có thể đối với mỗi máy tính xác định trước. Do đó, giá trị của m gần hoặc bằng 2^31 sẽ được lựa chọn.\nCó ba tiêu chí được sử dụng để đánh giá bộ tạo số ngẫu nhiên như sau:\n+ Hàm tạo sẽ là hàm tạo toàn chu kỳ. Nghĩa là, hàm tạo sẽ tạo ra tất cả các số từ 0 đến m-1 trước khi lặp lại.\n+ Chuỗi được tạo ra phải là ngẫu nhiên\n+ Hàm sẽ thực hiện một cách hiệu quả với số 32 bit.\nVới các giá trị thích hợp của a, c, và m, chuỗi số tạo ra có thể đáp ứng được ba tiêu chí đánh giá trên. Với tiêu chí đánh giá đầu tiên, nếu m là số nguyên tố và c=0, thì đối với giá trị nào đó của a, chu kỳ của hàm tạo số ngẫu nhiên sẽ là m-1. Đối với số 32 bit, giá trị nguyên tố của m là 2^31 - 1. Do đó, hàm tạo số ngẫu nhiên trở thành: X(n+1) = (aXn) mod (2^31 - 1)\nĐộ mạnh của thuật toán đồng dạng tuyến tính phụ thuộc vào số nhân a và m được lựa chọn. Tuy nhiên, không có sự ngẫu nhiên nào trong thuật toán, ngoại trừ việc lựa chọn giá trị khởi tạo X0. Khi giá trị đó được lựa chọn, các số còn lại là chuỗi theo sau được xác định. Điều này là lợi thế cho các kẻ tấn công. Nếu kẻ tấn công biết rằng thuật toán đồng dạng tuyến tính được sử dụng và nếu các tham số đã biết (ví dụ a=7^5, c=0, m = 2^31 - 1), thì khi một số được phát hiện ra, tất cả các số tiếp theo sẽ biết được, chỉ cần biết một phần nhỏ của chuỗi số là đủ để xác định các tham số của thuật toán.\n\n**Bộ tạo BBS (Blum Blum Shub)**\nMột phương pháp phổ biến để tạo các số giả ngẫu nhiên an toàn được biết như là bộ tạo BBS (hình 2.31). Hoạt động của bộ tạo BBS như sau. Đầu tiên, lựa chọn hai số nguyên tố lớn, p và q. Hai số đó khi chia cho 4 đều có số dư là 3, nghĩa là p(mod 4) = q(mod 4) = 3. Ví dụ, các số nguyên tố 7 và 11 đều thỏa mãn điều kiện trên. Đặt n = p x q.\nTiếp theo, chọn số ngẫu nhiên s, sao cho cả p và q đều không phải là thừa số của s. Sau đó, bộ tạo BBS tạo ra chuỗi bit Bi theo thuật toán sau:\nX0 = s^2 mod n\nfor i=1 to infinity\nXi = (Xi-1)^2 mod n\nBi = Xi mod 2\nDo đó, bit có ý nghĩa thấp nhất được lấy ra tại mỗi vòng lặp. BBS còn được gọi là bộ tạo bit giả ngẫu nhiên an toàn bảo mật (CSPRBG). Tính an toàn của BBS phụ thuộc vào hai thừa số nguyên tố p và q của n."
            },
            {
              "level_3_title": "2.5.3. Mật mã dòng",
              "level_3_id": "2.5.3",
              "content": "Mật mã dòng thực hiện mật mã bản rõ theo từng byte tại một thời điểm, mặc dù mật mã dòng có thể được thiết kế để hoạt động trên từng bit tại một thời điểm hoặc trên đơn vị lớn hơn 1 byte tại một thời điểm. Hình 2.32 đưa ra sơ đồ cấu trúc của mật mã dòng. Trong cấu trúc này, khóa là đầu vào của bộ tạo bit giả ngẫu nhiên. Bộ tạo bit giả ngẫu nhiên này tạo ra dòng số 8 bit ngẫu nhiên. Đầu ra của bộ tạo, được gọi là dòng khóa, được kết hợp một byte tại một thời điểm với dòng bản rõ sử dụng phép XOR. Ví dụ, nếu byte tiếp theo được tạo ra bởi bộ tạo này là 01101100 và byte bản rõ tiếp theo là 11001100, thì byte bản mã sẽ là 10100000. Giải mật mã yêu cầu sử dụng cùng chuỗi giả ngẫu nhiên. Như vậy, có thể thấy mật mã dòng tương tự như mật mã hóa One-Time Pad. Điểm quan trọng nhất của các mật mã dòng là bộ tạo số ngẫu nhiên. Nếu chọn khóa có chiều dài ngắn thì không bảo đảm an toàn, còn nếu chọn khóa có chiều dài bằng chiều dài bản tin như One-Time Pad thì lại không thực tế. Bộ tạo số của mật mã dòng cân bằng giữa hai điểm này, cho phép dùng một khóa ngắn nhưng dãy số tạo ra bảo đảm một độ ngẫu nhiên cần thiết như khóa của One-time Pad, dùng rằng không hoàn toàn thực sự ngẫu nhiên."
            },
            {
              "level_3_title": "2.5.4. RC4",
              "level_3_id": "2.5.4",
              "content": "RC4 là một phương pháp mật mã dòng được thiết kế vào năm 1987 bởi Ron Rivest cho RSA. Nó là một mật mã dòng có kích thước khóa thay đổi với các hoạt động hướng byte. Thuật toán được dựa trên việc sử dụng phép hoán vị ngẫu nhiên. RC4 được dùng trong giao thức SSL để bảo mật dữ liệu trong quá trình truyền dữ liệu giữa Web Server và trình duyệt Web. Ngoài ra RC4 còn được sử dụng trong giao thức mã hóa WEP và giao thức WPA (Wifi Protected Access) của mạng Wireless LAN.\nThuật toán RC4 là khá đơn giản. Khóa có độ dài thay đổi từ 1 tới 128 byte (8 đến 2048 bit) được sử dụng để khởi tạo vector S gồm 256 byte, với các phần tử là S[0], S[1],..., S[255]. Tại tất cả các thời điểm S gồm một hoán vị của tất cả các số 8 bit từ 0 đến 255. Đối với quá trình mật mã hóa và giải mật mã, byte k được tạo ra từ S bằng cách lựa chọn một trong 255 phần tử theo một cách có hệ thống. Khi mỗi giá trị của k được tạo ra, các phần tử trong S lại được hoán vị một lần nữa.\n\n**Khởi tạo S**\nĐể bắt đầu, các phần tử của S được thiết lập với các giá trị từ 0 đến 255 theo tứ tự tăng dần; nghĩa là S[0]=0, S[1]=1,..., S[255]=255. Một vector tạm thời T cũng được tạo ra. Nếu độ dài khóa K là 256 byte, thì K được chuyển tới T. Nếu không, đối với khóa có độ dài keylen byte, keylen phần tử đầu tiên của T được sao chép từ K, và sau đó K được lặp lại nhiều lần để điền đầy vào T. Hoạt động đó có thể tóm tắt như sau:\nfor i=0 to 255 do\nS[i]=i\nT[i]=K[i mod keylen];\nTiếp theo, T được sử dụng để tạo ra hoán vị đầu tiên của S, cụ thể như sau:\nj=0;\nfor i=0 to 255 do\nj=(j+S[i]+T[i]) mod 256;\nSwap (S[i], S[j])\nBởi vì phép toán thực hiện trên S chỉ là tráo đổi các phần tử của S, ảnh hưởng duy nhất là hoán vị. S vẫn chứa tất cả các số từ 0 đến 255.\n\n**Tạo dòng**\nKhi vector S đã được khởi tạo, khóa đầu vào không còn được sử dụng nữa. Việc tạo dòng được thực hiện như sau:\ni, j = 0;\nwhile (true)\ni = (i + 1) mod 256;\nj = (j + S[i]) mod 256;\nSwap (S[i], S[j]);\nt = (S[i] + S[j]) mod 256;\nk = S[t];\nĐể mật mã hóa, thực hiện phép XOR giá trị k với byte tiếp theo của bản rõ. Để giải mật mã, thực hiện XOR giá trị k với byte tiếp theo của bản mã. Quá trình tạo số của RC4 cũng tạo ra dãy số ngẫu nhiên, khó đoán trước, vì vậy RC4 đạt được mức độ an toàn cao hơn mật mã hóa One-Time Pad. Mật mã hóa RC4 hoàn toàn được thực hiện trên các số nguyên một byte do đó tối ưu cho việc thiết lập bằng phần mềm và tốc độ thực hiện nhanh hơn so với mật mã khối."
            }
          ]
        },
        {
          "level_2_title": "2.6. Kết luận chương 2",
          "level_2_id": "2.6",
          "content": "Trong chương này, các khái niệm cơ bản về mật mã hóa, mật mã khóa đối xứng, mật mã khối, và mật mã dòng được trình bày một cách chi tiết. Ngoài ra, các kiến trúc, nguyên lý thiết kế, và các ứng dụng của mật mã khối cũng được đưa ra. Cũng trong chương này, các giải thuật phổ biến như RC4, DES, và AES đã được mô tả và giải thích một cách đầy đủ và dễ hiểu.",
          "children": []
        },
        {
          "level_2_title": "2.7. Câu hỏi ôn tập chương 2",
          "level_2_id": "2.7",
          "content": "1. Trình bày các thành phần cơ bản của mật mã khóa đối xứng\n2. Trình bày cấu trúc chung của mật mã khối\n3. Trình bày sự khác nhau giữa mật mã khối và mật mã dòng\n4. Trình bày cấu trúc mật mã hóa và giải mật mã Feistel\n5. Trình bày cấu trúc DES\n6. Trình bày thuật toán sinh khóa con của DES\n7. Giải thích hiệu ứng lan truyền\n8. Trình bày nguyên lý thiết kế mật mã khối\n9. Trình bày cấu trúc AES\n10. Giải thích ý nghĩa và mục đích của các hàm biến đổi trong AES\n11. Phân biệt hai hàm SubBytes và Sub Word\n12. Phân biệt hai hàm ShiftRows và RotWord\n13. Trình bày quá trình tạo khóa AES\n14. Nêu và phân tích các kiểu mật mã hóa nhiều lần\n15. Trình bày các chế độ và ứng dụng mật mã khối\n16. Trình bày nguyên lý tạo số giả ngẫu nhiên\n17. Vẽ và phân tích sơ đồ mật mã dòng\n18. Trong mô hình mật mã Feistel, với khối n bit, chứng minh rằng số các phép ánh xạ thuận nghịch cho mật mã khối lý tưởng là (2^n)!.\n19. Tìm 8 từ đầu tiên của việc tạo khóa biết khóa 128 bit toàn bit 0\n20. Cho bản rõ {000102030405060708090A0B0C0D0E0F} và khóa {01010101010101010101010101010101}:\na. Tìm giá trị ma trận khởi tạo\nb. Tìm giá trị ma trận sau khối AddRoundKey khởi tạo\nc. Tìm giá trị ma trận sau SubBytes\nd. Tìm giá trị ma trận sau ShiftRows\ne. Tìm giá trị ma trận sau MixColumns",
          "children": []
        }
      ]
    },
    {
      "level_1_title": "Chương 3: Mật mã khóa bất đối xứng",
      "level_1_id": "3",
      "children": [
        {
          "level_2_title": "3.1. Mật mã khóa công khai và RSA",
          "level_2_id": "3.1",
          "children": [
            {
              "level_3_title": "3.1.1. Nguyên lí hệ thống mật mã khóa công khai",
              "level_3_id": "3.1.1",
              "content": "Khái niệm về mật mã khóa công khai phát triển từ hai trở ngại của mã hóa đối xứng. Vấn đề đầu tiên là phân phối khóa và vấn đề thứ hai là chữ ký số. Vấn đề phân phối khóa trong hệ mật đối xứng yêu cầu hoặc (1) hai thành viên cùng chia sẻ khóa và cách nào để phân phối cho chúng, hoặc (2) sử dụng một trung tâm phân phối khóa. Whitfield Diffie, người phát hiện ra mã hóa khóa công khai (cùng với Martin Hellman, Đại học Stanford), lý luận rằng yêu cầu thứ hai này phủ nhận bản chất của mật mã: khả năng duy trì bí mật tổng thể sẽ xâm phạm thông tin riêng tư. Vấn đề thứ hai không liên quan đến vấn đề đầu tiên là chữ ký kỹ thuật số. Nếu việc sử dụng mật mã đã trở nên phổ biến, không chỉ trong những tình huống quân sự mà còn trong thương mại và mục đích cá nhân, thì tin nhắn điện tử và các văn bản sẽ cần xác nhận tương đương với chữ ký được sử dụng trong các tài liệu giấy.",
              "children": [
                {
                  "level_4_title": "3.1.1.1. Hệ mật khóa công khai",
                  "level_4_id": "3.1.1.1",
                  "content": "Giải thuật bất đối xứng dựa trên cơ chế sử dụng một khóa để mã hóa và một khóa khác (có liên quan tới khóa mã) để giải mã. Các giải thuật này có đặc điểm quan trọng sau đây.\n+ Nó là tính toán khả thi để xác định một khóa giải mã duy nhất thông hiểu về thuật toán mã hóa và khóa mã hóa.\n+ Thêm vào đó, đối với một số thuật toán như RSA còn bổ sung một số đặc tính sau: Một trong hai khoá có liên quan có thể được sử dụng để mã hóa và khóa còn lại để giải mã.\nMột lưu đồ mã hóa khóa công khai có sáu thành phần (hình 3.1a);\n+ Plaintext (bản rõ): Đây là bản tin hoặc dữ liệu có thể đọc được và là đầu vào của thuật toán.\n+ Thuật toán mã hóa: Các thuật toán mã hóa thực hiện các biến đổi khác nhau trên bản rõ.\n+ Khóa công cộng và khóa riêng: Đây là một cặp chìa khóa đã được chọn để nếu một khóa được sử dụng để mã hóa, thì khóa kia được sử dụng để giải mã. Các phép chuyển đổi chính xác được thực hiện bởi các thuật toán phụ thuộc vào khóa công khai hoặc riêng mà được coi là các đầu vào.\n+ Bản mã: Đây là bản tin được tạo ra tại đầu ra thuật toán, nó phụ thuộc vào bản rõ và khóa. Đối với một bản tin, hai khóa khác nhau sẽ tạo ra hai bản mã khác nhau.\n+ Thuật toán giải mã: Thuật toán này chấp nhận các bản mã và khóa phù hợp để các bản rõ ban đầu.\nMột số bước cơ bản có thể gồm:\n+ Mỗi người sử dụng tạo ra một cặp khóa được sử dụng để mã hóa và giải mã các bản tin.\n+ Mỗi người sử dụng đặt một trong hai khóa làm khóa công cộng và khóa kia bí mật. Như hình 3.1a, mỗi người dùng duy trì một tập của các khóa công cộng thu được từ những người khác.\n+ Nếu Bob muốn gửi một bản tin bí mật cho Alice, Bob mã hóa bản tin bằng khóa công khai của Alice.\n+ Khi Alice nhận được bản tin, cô giải mã bằng khóa riêng của mình. Không người nhận nào khác có thể giải mã bản tin bởi vì chỉ có Alice biết khóa riêng của Alice.\nVới tiếp cận này, tất cả những thành viên tham gia đều có quyền truy cập vào các khóa công khai và khóa riêng được tạo cục bộ của từng người tham gia và không cần cơ chế phân phối. Chừng nào khóa riêng của người dùng được bảo vệ và bí mật, thì truyền thông là an toàn. Tại bất kỳ thời điểm nào, một hệ thống có thể thay đổi khóa riêng của nó và tạo ra khóa công khai mới để thay thế khóa công khai cũ.\nĐể phân biệt, ta coi các khóa được sử dụng trong mã hóa đối xứng như một khóa bí mật. Hai khóa được sử dụng để mã hóa bất đối xứng được gọi là khóa công khai và khóa riêng. Tất nhiên là khóa riêng được giữ bí mật, nhưng nó được gọi là khóa riêng chứ không phải là một khóa bí mật để tránh nhầm lẫn với mã hóa đối xứng.\nChúng ta hãy xem xét kỹ hơn các yếu tố thiết yếu của một lưu đồ mã hóa khóa công khai trên hình 3.2. Ở đây có một số nguồn A tạo ra một bản tin rõ, X=[X1, X2,..., XM]. M phần tử của X là các chữ cái trong bảng chữ cái. Bản tin này được gửi đến cho các điểm đến B. B tạo ra một cặp quan hệ của các khóa: một khóa công khai PUb và một khóa riêng PRb. Khóa PUb được công khai truy nhập bởi A. Với bản tin X và mã hóa bởi khóa PUb, A tạo các bản mã Y=[Y1, Y2,..., YN]: Y = E(PUb, X). Bên phía nhận có khóa riêng phù hợp, thực hiện biến đổi ngược: X = D(PRb, Y).\nMột kẻ tấn công quan sát Y và có quyền truy cập vào PUb, nhưng không có quyền truy cập vào PRb hoặc X, phải cố gắng để khôi phục lại X và / hoặc PRb. Giả thiết rằng, kẻ tấn công không biết về sự thuật tóan mã hóa (E) và giải mã (D). Nếu kẻ tấn công chỉ quan tâm đến bản tin cụ thể, thì sẽ tập trung vào mục tiêu khôi phục X bằng cách tạo ra một bản rõ ước tính X^. Thông thường, kẻ tấn công thường hướng đến các bản tin tương lai và hướng đến sự khôi phục PRb bằng cách tạo ra một ước tính PR^b.\nTa đã biết, một trong hai khoá có liên quan có thể được sử dụng để mã hóa, và khóa khác đang được sử dụng để giải mã. Điều này cho phép nhiều hơn một lược đồ mã hóa khác nhau thực hiện. Lưu đồ trong hình 3.2 cung cấp bảo mật, và lưu đồ trong 3.1 và 3.3 sử dụng khóa công khai để cung cấp nhận thực:\nY = E(PUa, X)\nX = D(PUa, Y)\nTrong trường hợp này, A chuẩn bị một bản tin đến B và mã hóa nó bằng khóa riêng của mình trước khi truyền nó. B có thể giải mã các bản tin bằng khóa công khai của nó. Bởi vì các bản tin được mã hóa bằng khóa riêng của A, thì chỉ có duy nhất A tạo ra được bản tin như vậy. Vì thế, toàn bộ bản tin được mã hóa phục vụ như một chữ ký kỹ thuật số. Thêm vào đó, không thể thay đổi được bản tin mà không truy cập vào khóa riêng của A, nên bản tin được xác thực cả về nguồn và về tính toàn vẹn của dữ liệu.\nĐiều quan trọng cần nhấn mạnh là quá trình mã hóa được mô tả trong Hình 3.1b và 3.3 không cung cấp bảo mật. Vì thế, bản tin được gửi an toàn khi không có sự thay đổi nhưng không phải từ việc nghe trộm. Đây là rõ ràng trong trường hợp của một chữ ký dựa trên một phần của bản tin, vì phần còn lại của bản tin được truyền rõ ràng. Ngay cả trong trường hợp mã hóa toàn bộ như trong hình 3.3, thì bản tin cũng không bí mật bởi vì bất kỳ người khác nào đều có thể giải mã bản tin bằng cách sử dụng khóa công khai của người gửi.\nTuy nhiên, có thể cung cấp cả chức năng xác thực và bảo mật bằng việc sử dụng kép hai lược đồ khóa công khai (hình 9.4 [3.4]):\nZ = E (PUb, E (PRa, X))\nX = D (PUa, D (PRb, Z))\nTrong trường hợp này, ta bắt đầu như trước bằng cách mã hóa một bản tin, sử dụng khóa của người gửi tin để cung cấp chức năng ký kỹ thuật số. Sau đó, ta mã hóa một lần nữa, bằng cách sử dụng khóa công khai của người nhận, bản mã cuối cùng có thể được giải mã chỉ của người nhận có khóa riêng phù hợp và đảm bảo tính bảo mật. Điểm bất lợi của tiếp cận này là độ phức tạp của thuật toán mã khóa công khai, phải thực hiện bốn lần thay vì hai lần trong mỗi phiên truyền thông."
                },
                {
                  "level_4_title": "3.1.1.2. Các ứng dụng cho hệ mật khóa công khai",
                  "level_4_id": "3.1.1.2",
                  "content": "Một hệ mật khóa công khai được đặc trưng bởi việc sử dụng các thuật toán mã hóa và hai khóa. Tùy thuộc vào ứng dụng, bên gửi có thể gửi khóa bí mật, khóa riêng hoặc cả hai cho bên nhận và tạo thành các kiểu chức năng của hệ mật. Hệ mật khóa công khai có thể chia thành 3 dạng:\n+ Mã hóa / giải mã: Người gửi sẽ mã hóa một bản tin với người nhận khóa công khai.\n+ Chữ ký kỹ thuật số: Người gửi \"ký\" một tin nhắn với khóa riêng của họ. Ký được thực hiện bởi một thuật toán mãhóa áp dụng cho cả bản tin hoặc một phần của bản tin.\n+ Trao đổi khóa: Hai bên hợp tác để trao đổi khóa phiên. Một số tiếp cận khác nhau được tạo ra liên quan đến các khóa riêng của một hoặc cả hai bên.\nMột số thuật toán phù hợp cho tất cả ba ứng dụng trên, trong khi các thuật toán khác có thể chỉ được sử dụng cho một hoặc hai trong số các ứng dụng này."
                },
                {
                  "level_4_title": "3.1.1.3. Các yêu cầu đối với hệ mật khóa công khai",
                  "level_4_id": "3.1.1.3",
                  "content": "Các hệ thống mật mã minh họa trong hình 3.2 tới 3.4 phụ thuộc vào một thuật toán mã hóa với hai khóa liên quan. Diffie và Hellman mặc nhiên công nhận hệ thống này mà không cần chứng minh rằng các thuật toán như vậy có tồn tại hay không. Tuy nhiên, họ đã đặt ra các điều kiện cho thuật toán phải được thực hiện gồm:\n+ Tính toán dễ dàng cho phía bên B để tạo ra một cặp khóa (công cộng PUb, khóa riêng PRb).\n+ Tính toán dễ dàng cho một người gửi A, biết khóa công khai và bản tin được mã hóa, M, để tạo ra các bản mã tương ứng: C = E(PUb, M)\n+ Tính toán dễ dàng cho người nhận B để giải mã bản mã bằng cách sử dụng khóa riêng để phục hồi bản tin gốc: M = D(PRb, C) = D[PRb, E(PUb, M)]\n+ Tính toán không khả thi đối với kẻ tấn công khi biết khóa công khai, nhằm xác định khóa riêng."
                }
              ]
            },
            {
              "level_3_title": "3.1.2. Giải thuật RSA",
              "level_3_id": "3.1.2",
              "content": "Thuật toán Rivest-Shamir-Adleman (RSA) là thuật toán mã hóa khóa công khai được các tác giả Ronal Rivest, Adi Shamir và Leonard Adleman phát triển tại Học Viện Công nghệ Masachusetts (MIT) vào năm 1977. Đây là thuật toán đầu tiên phù hợp với việc tạo ra chữ ký điện tử đồng thời với việc mã hóa. Nó đánh dấu một sự tiến bộ vượt bậc của lĩnh vực mật mã học trong việc sử dụng khóa công cộng. RSA đang được sử dụng phổ biến trong thương mại điện tử và được cho là đảm bảo an toàn với điều kiện độ dài khóa đủ lớn.",
              "children": [
                {
                  "level_4_title": "3.1.2.1. Mô tả thuật toán",
                  "level_4_id": "3.1.2.1",
                  "content": "RSA tạo một biểu thức với các hàm mũ, bản rõ được mã hóa trong các khối, với mỗi khối có một giá trị nhị phân nhỏ hơn một số n. Vì vậy, các khối kích thước phải nhỏ hơn hoặc bằng log2(n) + 1; trong thực tế, kích thước khối là i bit, với 2^i < n <= 2^(i+1). Mã hóa và giải mã được thực hiện theo dạng sau (các khối bản rõ M và bản mã C):\nC = M^e mod n\nM = C^d mod n = (M^e)^d mod n = M^(ed) mod n\nCả người gửi và người nhận phải biết giá trị của n. Người gửi biết giá trị của e, và chỉ có người nhận biết được giá trị của d. Như vậy, đây là một thuật toán mã hóa khóa công khai với một khóa công khai của PU={e,n} và một khóa riêng của PR={d,n}. Đối với thuật toán này, để thỏa mãn cho việc mã hóa khóa công khai, các yêu cầu sau đây phải được đáp ứng.\n1. Có thể tìm thấy giá trị của e, d, và n sao cho M^(ed) mod n = M cho tất cả giá trị M < n.\n2. Nó là tương đối dễ dàng để tính toán M^e mod n và C^d mod n cho tất cả các giá trị của M < n.\n3. Nó có tính khả thi để xác định d khi biết e và n.\nTa cần tìm mối quan hệ M^(ed) mod n = M. Các mối quan hệ trước đó giữ nếu e và d là nhân nghịch đảo theo modulo phi(n), với phi(n) là hàm Euler. Nó được biểu diễn cho p, q là các số nguyên tố, phi(n) = phi(p,q) = (p-1)x(q-1). Mối quan hệ giữa e và d có thể được thể hiện như sau:\ned mod phi(n) = 1\nĐiều này tương đương với ed đồng dư 1 mod phi(n) hay d đồng dư e^-1 mod phi(n). Vì vậy, e và d là nhân nghịch đảo của modulo phi(n). Lưu ý rằng, theo quy tắc của số học modul, điều này chỉ đúng nếu d (và do đó e) là nguyên tố cùng nhau với phi(n). Ta tính toán RSA theo các thành phần như sau:\np, q, hai số nguyên tố (riêng, lựa chọn)\nn = pq (công cộng, tính toán được)\ne, với gcd(phi(n),e)=1; 1<e<phi(n) (công khai, lựa chọn)\nd đồng dư e^-1 mod phi(n) (riêng, tính toán được)\nCác khóa riêng gồm {d, n} và khóa công khai bao gồm {e, n}. Giả sử rằng người dùng A đã đưa ra khóa công khai của mình và rằng người dùng B muốn gửi bản tin M tới A. Thì B sẽ tính toán C = M^e mod n và truyền C. Khi nhận được bản mã này, người dùng A giải mã bằng cách tính toán M = C^d mod n.\n\n**Các khía cạnh tính toán**\n(i) Vấn đề độ phức tạp tính toán cần thiết khi sử dụng RSA là một vấn đề quan trọng. Trên thực tế, có hai vấn đề cần xem xét: mã hóa / giải mã và tạo khóa.\nHàm mũ trong tính toán mudulo: Cả vấn đề mã hóa và giải mã trong RSA đều liên quan từ số nguyên tới lũy thừa số nguyên, mod n. Nếu một phép tính lũy thừa được thực hiện trên số nguyên rồi giảm theo module n, thì các giá trị trung gian sẽ cực lớn. Ví dụ dưới đây sẽ sử dụng đặc tính tính toán modulo.\n[(a mod n) * (b mod n)] mod n = (a*b) mod n\nNhư vậy, chúng ta có thể làm giảm số kết quả trung gian modulo n. Điều này làm cho việc tính toán thực tế hơn. Một khía cạnh khác là hiệu quả của hàm mũ do RSA thường đưa ra các hàm mũ lớn.\nHoạt động hiệu quả sử dụng khóa công khai: Để tăng tốc độ hoạt động của thuật toán RSA bằng cách sử dụng khóa công khai, ta thường lựa chọn e đặc biệt. Lựa chọn e phổ biến là 65537; hoặc e chọn là 3 và 17. Lựa chọn này chỉ cần sử dụng sử dụng hai số (1 bit) nên số lượng các phép nhân cần thiết để thực hiện các lũy thừa được giảm thiểu. Tuy nhiên, với một khóa công khai rất nhỏ như e=3, RSA trở nên dễ bị tổn thương với một cuộc tấn công đơn giản.\nHoạt động hiệu quả sử dụng khóa riêng: Tương tự ta không thể lựa chọn một hằng số có giá trị nhỏ của d. Gía trị mà nhỏ sẽ dễ bị tấn công cưỡng bức và bị một số kiểu phân tích mật mã khác. Tuy nhiên có một cách để đẩy nhanh tốc độ tính toán sử dụng CRT. Ta muốn tính giá trị M = C^d mod n. Ta xác định các kết quả trung gian sau:\nVp = C^d mod p\nVq = C^d mod q\nTiếp theo CRT chỉ ra chất lượng Xp = q x (q^-1 mod p) và Xq = p x (p^-1 mod q). Sau đó CRT biểu diễn M = (VpXp + VqXq) mod n. Kết quả cuối cùng việc tính toán nhanh hơn xấp xỉ 4 lần so với tính trực tiếp.\nTạo khóa: Trước khi áp dụng hệ thống mật mã khóa công khai RSA, mỗi bên tham gia phải tạo ra một cặp khóa theo các bước sau:\n+ Xác định 2 số nguyên tố p và q\n+ Lựa chọn hoặc e hoặc d và tính toán cái còn lại.\nBởi vì giá trị n=pq sẽ bị phát hiện bởi bất kỳ kẻ theo dõi tiềm năng nào, nên những số nguyên tố này phải được chọn từ tập đủ lớn tức là p và q phải là những số lớn. Mặt khác phương pháp sử dụng để tìm các số nguyên phải có hiệu quả hợp lý. Hiện tại không có những kỹ thuật hữu hiệu để thu được các số nguyên tố lớn một cách tùy ý nên cần một số cách thức để xử lý vấn đề này. Thủ tục là nhặt ngẫu nhiên một số lẻ nằm trong độ lớn mong muốn và kiểm tra xem nó có phải là số nguyên tố không. Nếu không phải nhặt lại các số ngẫu nhiên khác cho đến khi nó là số nguyên tố. Thủ tục để kiểm tra xem một số nguyên cho trước n nào đó có phải là số nguyên tố là thực hiện một số tính toán liên quan đến n và một số nguyên ngẫu nhiên a. Nếu n không vượt qua phép thử thì n không phải là số nguyên tố. Nếu n “vượt qua” phép thử thì n có thể là số nguyên tố hoặc là không. Nếu n vượt qua một số lượng phép thử các giá trị a khác nhau được lựa chọn ngẫu nhiên thì ta có thể tin chắc n là số nguyên tố.\n\n**(ii) Vấn đề bảo mật của RSA**\nCó 5 khả năng để tấn công thuật toán RSA:\n+ Tấn công cưỡng bức: Cố gắng bằng mọi khả năng tìm ra khóa riêng.\n+ Tấn công toán học: Nỗ lực tìm ra tích của 2 số nguyên tố.\n+ Tấn công thời gian: Phụ thuộc vào thời gian hoạt động của thuật toán giải mã.\n+ Tấn công dựa trên lỗi phần cứng: Gây ra các lỗi phần cứng trong bộ xử lý tạo ra các chữ ký số.\n+ Tấn công vào bản mã: Kiểu tấn công này khai thác các đặc tính của thuật toán RSA.\nViệc chống lại tấn công cưỡng bức thì đối với thuật toán RSA hay các hệ thống mật mã khác đều bằng cách sử dụng không gian khóa đủ lớn. Tức là số lượng bit trong d càng lớn càng tốt. Tuy nhiên việc tính toán trong cả việc tạo khóa và việc mật mã hóa/giải mã đều phức tạp nên kích thước khóa càng lớn thì hệ thống hoạt động càng chậm.\nBài toán tìm thừa số là tiếp cận tấn công toán học vào RSA. Các hướng giải mật mã RSA đều tập trung vào nhiệm vụ tìm ra n từ 2 thừa số nguyên tố. Với thuật toán đã biết việc xác định với e và n đã cho ít nhất cũng tiêu tốn thời gian như bài toán phân tích thừa số. Vì vậy chúng ta có thể dùng cách này như một điểm chốt trong tính bảo mật của RSA. Nếu n lớn thì việc phân tích ra nó là rất khó khăn. Việc đe dọa vào kích thước khóa lớn đã tăng lên gấp đôi bởi năng lực tính toán của máy tính đang ngày càng tăng và các thuật toán tìm thừa số tiếp tục được hoàn chỉnh. Như vậy chúng ta cần cẩn thận trong việc lựa chọn kích thước khóa cho RSA. Ngoài việc xác định kích thước của n, một số các ràng buộc khác cũng được gợi ý bởi các nhà nghiên cứu để tránh một số giá trị của n mà có thể tìm ra một cách dễ dàng:\n1. p và q nên khác nhau về độ dài trong vài con số.\n2. Cả (p-1) và (q-1) đều là số nguyên tố lớn.\n3. Gcd(p-1, q-1) có thể nhỏ.\nThêm nữa cần phải nhấn mạnh rằng nếu e < n và d < n^(1/4) thì d có thể dễ dàng được xác định.\nTấn công thời gian: Tấn công thời gian cũng thể hiện được sự khó khăn để phá vỡ tính an toàn của thuật toán mật mã hóa. Paul Kocher, một chuyên gia mật mã hóa, đã nhấn mạnh rằng một kẻ đi rình có thể xác định được khóa riêng biệt bằng việc theo dõi thời gian một máy tính đưa ra bản giải mã. Tấn công thời gian không chỉ áp dụng cho RSA mà cho cả các hệ thống mật mã khóa công khai khác. Việc tấn công này có thể đến từ bất kỳ hướng nào và chỉ tấn công vào bản mã. Mặc dù tấn công thời gian rất nguy hiểm nhưng cũng đã có một số phương pháp đối phó được sử dụng:\n+ Thời gian mũ hóa là hằng số: Đảm bảo việc mũ hóa được thực hiện hết cùng một khoảng thời gian. Việc này là đơn giản nhưng lại bị giảm hiệu suất.\n+ Trễ ngẫu nhiên: Thực hiện thêm một độ trễ ngẫu nhiên vào thuật toán mũ hóa để làm rối loạn tấn công thời gian.\n+ Làm đầy: Nhân bản mã với một số ngẫu nhiên trước khi thực hiện mũ hóa. Tiến trình này ngăn kẻ tấn công biết được các bit của bản mã được xử lý ở trong máy tính và từ đó ngăn được việc thực hiện phân tích thời gian theo từng bit của tấn công thời gian.\nTấn công dựa trên lỗi: Một tiếp cận tấn công RSA không chính thống nữa là tấn công vào bộ xử lý tạo ra chữ ký số RSA. Việc tấn công này gây ra lỗi trong việc tính toán chữ ký số bằng việc giảm năng lực của bộ vi xử lý. Các lỗi gây ra bởi phần mềm tạo ra các chữ ký không đủ năng lực có thể bị phân tích bởi kẻ tấn công nhằm tìm ra khóa riêng. Thuật toán tấn công gây ra các lỗi bit đơn và bắt lấy kết quả. Kiểu tấn công này có vẻ không gây nguy hiểm nghiêm trọng cho RSA. Nó yêu cầu kẻ tấn công phải truy nhập vật lý đến thiết bị và kẻ tấn công phải có khả năng điều khiển trực tiếp công suất đầu vào của vi xử lý.\nTấn công bản mã lựa chọn và đệm mật mã bất đối xứng tối ưu: Thuật toán RSA cơ sở có thể bị tấn công gọi là tấn công bản mã lựa chọn (CCA). CCA được định nghĩa là một kẻ tấn công chọn ra một số bản mã và sau đó tìm ra bản rõ tương ứng, giải mã với khóa riêng của đích. Để chống lại tấn công này ta thay đổi bản rõ sử dụng thủ tục đệm mật mã bất đối xứng tối ưu (OAEP)."
                }
              ]
            }
          ]
        },
        {
          "level_2_title": "3.2. Trao đổi khóa Diffie-Hellman",
          "level_2_id": "3.2",
          "content": "Thuật toán khóa công khai đầu tiên được xuất hiện trong báo cáo của Diffie và Hellman được gọi là mật mã khóa công khai và thường được nhắc đến là trao đổi khóa Diffie-Hellman. Một loạt các sản phẩm thương mại đã sử dụng kỹ thuật trao đổi khóa này. Mục đích của thuật toán là cho phép 2 người dùng trao đổi một cách an toàn một khóa mà sau đó có thể được dùng để mã hóa đối xứng các bản tin. Bản thân thuật toán đơn giản hóa là sự trao đổi những giá trị bí mật. Hiệu quả của thuật toán Diffie-Hellman là dựa vào những trở ngại trong việc tính toán của các thuật toán rời rạc.\nNói một cách ngắn gọn, chúng ta có thể định nghĩa thuật toán rời rạc theo cách sau đây. Gốc ban đầu của một số nguyên tố p là một số mà lũy thừa của nó modulo p tạo ra tất cả các số nguyên từ 1 đến p-1. Có nghĩa là nếu a là một gốc ban đầu của một số nguyên tố p thì các số a mod p, a^2 mod p,..., a^(p-1) mod p là các số nguyên phân biệt từ 1 đến p-1. Với bất kỳ số nguyên b và một gốc ban đầu a của số nguyên tố p, ta có thể tìm ra một số mũ duy nhất i sao cho: b đồng dư a^i (mod p) với 0 <= i <= (p-1). Số mũ i được gọi là thuật toán rời rạc của b với căn nguyên thủy a mod p. Chúng ta thể hiện giá trị này là dlog_a,p(b).\n\n**Thuật toán:**\nHình 3.10 tóm lược thuật toán trao đổi khóa Diffie-Hellman. Trong trường hợp này có 2 số đã biết: một số nguyên tố q và một số nguyên a là căn nguyên thủy của q. Gia sử người dùng A và B muốn tạo ra một khóa chia sẻ. Người dùng A chọn một số nguyên ngẫu nhiên XA < q và tính toán YA = a^XA mod q. Tương tự người dùng B độc lập lựa chọn một số nguyên XB < q và tính toán YB = a^XB mod q. Mỗi bên giữ giá trị X của mình và tạo ra giá trị Y công khai với bên kia. Như vậy XA là khóa riêng của A và YA tương ứng là khóa công khai. Tương tự như thế đối với B. Người dùng A tính toán khóa là K = (YB)^XA mod q và người dùng B tính toán khóa là K = (YA)^XB mod q. Cả hai tính toán này tạo ra các kết quả độc lập: K = (YB)^XA mod q = (a^XB mod q)^XA mod q = (a^XB)^XA mod q = a^(XB*XA) mod q = (a^XA)^XB mod q = (a^XA mod q)^XB mod q = (YA)^XB mod q\nKết quả là hai bên đã trao đổi một giá trị bí mật. Gía trị bí mật này được dùng như là một khóa bí mật đối xứng được chia sẻ. Nếu một ai nào đó bắt được quá trình trao đổi khóa và muốn tìm khóa bí mật K thì vì XA và XB được giữ riêng, kẻ theo dõi chỉ có thể biết được các thành phần q, a, YA và YB. Như vậy kẻ theo dõi buộc phải thực hiện một thuật toán rời rạc để xác định khóa. Ví dụ, để xác định khóa giữ riêng của người dùng B kẻ theo dõi phải tính toán XB = dlog_a,q(YB). Người theo dõi có thể tính toán khóa K theo như cách người dùng B tính toán. Như vậy kẻ theo dõi sẽ tính được K là K = (YA)^XB mod q.\nTính an toàn của trao đổi khóa Diffie-Hellman dựa vào thực tế là nó có vẻ dễ dàng tính được modulo số mũ của một số nguyên nhưng lại rất khó để tính được các logarit rời rạc. Đối với các số nguyên lớn thì nhiệm vụ này có thể coi như bất khả thi.\n\n**Các giao thức trao đổi khóa:**\nHình 3.10 chỉ ra một giao thức đơn giản sử dụng tính toán Diffie-Hellman. Gia sử rằng người dùng A muốn thiết lập một kết nối với người dùng B và sử dụng một khóa bí mật để mã hóa các bản tin trên kết nối đó. Người dùng A có thể tạo ra khóa riêng sử dụng một lần XA tính toán YA và gửi nó cho người dùng B. Người dùng B đáp lại bằng cách tạo ra một giá trị riêng XB, tính toán ra YB và gửi YB tới A. Lúc này cả 2 người dùng đều có thể tính toán ra khóa. Các giá trị công khai q và a cần được biết trước đó có thể ngay trong bản tin đầu tiên.\nMột ví dụ khác trong việc sử dụng thuật toán Diffie-Hellman là mỗi người trong một nhóm các người dùng (người dùng trong một mạng LAN) tạo ra một giá trị riêng lâu dài Xi (cho người dùng i) và tính toán ra giá trị công khai Yi. Các khóa công khai này kết hợp với giá trị công khai toàn cục q và a được lưu trữ ở trung tâm. Bất kỳ lúc nào người dùng j cũng có thể truy nhập để có được khóa công khai của i, tính toán ra một khóa bí mật và sử dụng nó để mật mã các bản tin gửi đến người dùng A. Nếu như nơi lưu trữ trung tâm đáng tin cậy thì kiểu trao đổi thông tin này cung cấp cả tính bảo mật và tính xác thực. Bởi vì chỉ có i và j mới có thể xác định được khóa, không người dùng nào khác có thể đọc được bản tin (tính bảo mật). Người nhận i biết rằng chỉ người dùng j mới có thể tạo ra một bản tin sử dụng khóa này (tính xác thực). Tuy nhiên kỹ thuật này không chống lại được kẻ tấn công phát lại.\n\n**Kẻ tấn công ở giữa**\nGiao thức chỉ ra trên hình 3.10 không an toàn để chống lại kẻ tấn công ở giữa. Gia sử Alice và Bob muốn trao đổi khóa và Darth là kẻ theo dõi. Việc tấn công diễn ra như sau:\n1. Darth chuẩn bị cho quá trình tấn công bằng việc tạo ra 2 khóa ngẫu nhiên XD1 và XD2. Sau đó tính toán ra khóa công khai tương ứng là YD1 và YD2.\n2. Alice gửi YA sang cho Bob.\n3. Darth xen vào nhận YA và gửi YD1 cho Bob. Darth cũng tính toán K2=(YA)^XD2 mod q.\n4. Bob nhận được YD1 và tính toán K1=(YD1)^XB mod q.\n5. Bob gửi YB cho Alice.\n6. Darth xen vào nhận YB và gửi YD2 cho Alice. Darth tính toán K1=(YB)^XD1 mod q.\n7. Alice nhận YD2 và tính toán K2=(YD2)^XA mod q\nỞ đây, Bob và Alice đều nghĩ rằng họ chia sẻ một khóa bí mật nhưng thay vào đó là Bob và Darth chia sẻ khóa bí mật K1, Darth và Alice chia sẻ khóa bí mật K2. Tất cả những thông tin trao đổi giữa Bob và Alice đều được thỏa hiệp.\nGiao thức trao đổi khóa có thể bị tấn công bởi vì nó không có sự nhận thực các bên tham gia. Ta có thể giải quyết vấn đề này bằng việc sử dụng chữ ký số và chứng nhận khóa công khai.",
          "children": []
        },
        {
          "level_2_title": "3.3. Hệ thống mật mã Elgamal",
          "level_2_id": "3.3",
          "content": "Vào năm 1984, T.Elgamal đã công bố một hệ thống mã công khai dựa trên logarit rời rạc, rất gần với kĩ thuật Diffie-Hellman. Hệ mật mã Elgamal được dùng dưới nhiều dạng trong một số các chuẩn, bao gồm chuẩn chữ kí số (DSS) và chuẩn S/MIME e-mail. Giống như mã Diffie-Hellman, các yếu tố cơ bản của mật mã Elgamal là số nguyên tố q và căn nguyên thuỷ a của q.\nNgười dùng A tạo một khóa cá nhân/công khai như sau:\n1. Tạo một số nguyên XA bất kì, sao cho 1 < XA < q-1.\n2. Tính toán YA = a^XA mod q\n3. Khóa cá nhân của A là XA và khóa công khai của A là {q, a, YA}.\nBất kì người dùng B nào có quyền truy cập vào khóa công khai của A có thể mã hoá một bản tin như sau:\n1. Biểu diễn bản tin dưới dạng một số nguyên M thuộc khoảng 0 <= M <= q-1 Các bản tin dài hơn được gửi như một chuỗi các khối mà trong đó mỗi khỗi là một số nguyên nhỏ hơn q.\n2. Chọn một số nguyên bất kì k sao cho 1 <= k <= q-1.\n3. Tình khoá dùng một lần K = (YA)^k mod q.\n4. Mã hoá M như một cặp số nguyên (C1, C2) sao cho C1 = a^k mod q; C2 = K*M mod q\nNgười dùng A khôi phục bản rõ như sau\n1. Khôi phục khoá bằng cách tính K = (C1)^XA mod q\n2. Tính M = (C2*K^-1) mod q.\nChúng ta sẽ giải thích hoạt động của hệ thống mật mã Elgamal. Đầu tiên chúng ta sẽ trình bày cách mà K được khôi phục bởi tiến trình giải mã:\nK = (YA)^k mod q = (a^XA mod q)^k mod q = a^(kXA) mod q\nK = (C1)^XA mod q = (a^k mod q)^XA mod q\nTiếp theo, bằng cách dùng K, ta khôi phục bản rõ:\nC2 = K*M mod q\n(C2*K^-1) mod q = K*M*K^-1 mod q = M mod q = M\nTính bảo mật của hệ thống mật mã Elgamal dưa trên độ khó trong tính toán hàm logarit rời rạc. Để khôi phục mã cá nhân của A, một người theo dõi phải tính XA = dlog_a,q(YA). Một cách khác, để khôi phục mã dùng một lần K, một người theo dõi phải tìm được số bất kì k, và việc này yêu cầu tính toán hàm logarit rời rạc k = dlog_a,q(C1). Các phép tính này được coi là không thể thực hiện được nếu p có ít nhấn 300 con số thập phân và q-1 có ít nhất một nhân tử nguyên tố lớn.",
          "children": []
        },
        {
          "level_2_title": "3.4. Tạo số giả ngẫu nhiên sử dụng mật mã bất đối xứng",
          "level_2_id": "3.4",
          "content": "Như chúng ta đã biết là bởi mật mã khối đối xứng tạo ra một đầu ra ngẫu nhiên nó có thể được xem như cơ sở của bộ tạo số giả ngẫu nhiên (PRNG). Tương tự như vậy một thuật toán mã hóa không đối xứng tạo đầu ra ngẫu nhiên cũng có thể sử dụng để xây dựng nên bộ PRNG. Tuy nhiên các thuật toán không đối xứng thường chậm hơn so với thuật toán đối xứng nên nó không được dùng để tạo ra các luồng bit PRNG có kết thúc mở. Hơn nữa tiếp cận không đối xứng là hữu dụng với việc tạo ra hàm giả ngẫu nhiên PRF để tạo ra chuỗi bit giả ngắn. Trong phần này chúng ta xem xét 2 thiết kế PRNG dựa trên các hàm giả ngẫu nhiên.\n\n**PRNG dựa trên RSA**\nĐối với một độ dài khóa vừa đủ, thuật toán RSA được xem là an toàn và là ứng viên tốt để làm cơ sở bộ PRNG như bộ PRNG được biết đến là PRNG Micali-Schnorr được khuyến nghị trong tiêu chuẩn X9.82 (bộ tạo số ngẫu nhiên) của ANSI và chuẩn 18031 (bộ tạo bit ngẫu nhiên) của ISO. PRNG có nhiều nét cấu trúc giống với kiểu phản hồi đầu ra OFB được sử dụng như một PRNG. Trong trường hợp này thuật toán mật mã hóa RSA được dùng nhiều hơn là mật mã khối đối xứng. Thêm nữa phần đầu ra được đưa quay trở lại ở vòng lặp tiếp theo của thuật toán mã hóa và phần còn lại của đầu ra được sử dụng là các bit giả ngẫu nhiên. Việc phân chia đầu ra thành 2 phần riêng biệt là để các bit giả ngẫu nhiên của tầng này không phải là đầu vào của tầng kế tiếp. Sự phân chia này có thể đóng góp vào việc chuyển tiếp không thể đoán trước.\n\n**PRNG dựa trên mã hoá theo đường cong elip**\nTrong phần này, chúng ta sẽ tóm lược ngắn gọn một kĩ thuật được phát triển bởi Bộ An Ninh Quốc Gia Hoa Kì (NSA) được biết đến là đường cong elip đôi PRNG (DEC PRNG). Kĩ thuật này được đề xuất trong NIST SP 800- 90, chuẩn X9.82 của ANSI và chuẩn ISO 18031. Tóm tắt thuật toán được trình bày như sau: Cho P và Q là 2 điểm đã biết trên đường cong elip. Giá trị khởi tạo của DEC PRNG là một số nguyên bất kì s0 thuộc {0,1,…,#E(GF(p))} mà #E(GF(p)) biểu diễn số điểm trên đường cong. Cho lsbi(s) biểu diễn i là bit nhỏ nhất của số nguyên s. DEC PRNG biến giá trị khởi tạo thành một chuỗi giả ngẫu nhiên dài 240k, k>0, như sau:\nFor i = 1 to k do\nSet s_i <- x(s_i-1 * P)\nSet r_i <- lsb_240 (x(s_i * Q))\nend for\nReturn r1,…, rk\nVề vấn đề an ninh PRNG, lí do duy nhất để nó được sử dụng là nó dùng trong một hệ thống đã cài đặt ECC nhưng không cài đặt bất kì thuật toán bảo mật đối xứng, bất đối xứng, hoặc cứng nào mà có thể sử dụng để dựng nên PRNG.",
          "children": []
        },
        {
          "level_2_title": "3.5. Câu hỏi ôn tập chương 3",
          "level_2_id": "3.5",
          "content": "1. Các đặc trưng cơ bản và ưu nhược điểm của hệ mật khóa công khai.\n2. Khía cạnh bảo mật và nhận thực của hệ thống mã hóa công khai.\n3. Mô tả giải thuật và các đặc tính cơ bản của RSA.\n4. Khả năng an toàn của RSA.\n5. Nguyên lý trao đổi khóa Diffie-Hellman.\n6. Khái quát đặc trưng của thống mật mã Elgamal",
          "children": []
        }
      ]
    },
    {
      "level_1_title": "Chương 4: Các giải thuật toàn vẹn dữ liệu",
      "level_1_id": "4",
      "children": [
        {
          "level_2_title": "4.1. Hàm băm",
          "level_2_id": "4.1",
          "children": [
            {
              "level_3_title": "4.1.1. Ứng dụng của hàm băm",
              "level_3_id": "4.1.1",
              "content": "Hàm băm được xem là thuật toán mã hoá linh hoạt nhất trong các loại thuật toán mã hoá và được sử dụng rộng rãi trong nhiều ứng dụng bảo mật và giao thức Internet. Để hiểu rõ về các yêu cầu và tác động bảo mật của các hàm băm mã hóa, ta sẽ xem xét các miền ứng dụng được triển khai hàm băm.\n\n**Xác thực bản tin**\nXác thực bản tin là một cơ chế hay dịch vụ được dùng để xác minh tính toàn vẹn của bản tin; nghĩa là đảm bảo nội dung bản tin nhận được chính xác như bản tin gửi đi (không có bất kỳ sự sửa đổi, chèn, xoá nội dung, lặp lại nào của bản tin). Trong nhiều trường hợp thì cơ chế xác thực đưa ra yêu cầu xác thực đối với người gửi. Hàm băm được sử dụng trong cơ chế xác thực bản tin để cung cấp một giá trị băm, thường được gọi là bản tin rút gọn. Bản chất của việc áp dụng hàm băm trong cơ chế xác thực như sau: Người gửi tính toán một giá trị băm từ các bit trong bản tin và truyền đi đồng thời bản tin và giá trị băm đó. Người nhận cũng thực hiện việc tính giá trị băm tương tự từ các bit trong bản tin nhận được và so sánh với giá trị băm được gửi kèm. Nếu như các giá trị băm được so sánh không trùng với nhau thì có nghĩa là bản tin nhận được (hoặc các giá trị băm) đã bị thay đổi. Các hàm băm phải được truyền đi một cách an toàn. Điều này nghĩa là ngay cả khi bản tin bị sửa đổi hoặc thay thế thì kẻ xấu không thể thay đổi được giá trị băm để đánh lừa người nhận.\n\n**Tạo chữ ký số**\nCác hàm băm có thể được sử dụng để tạo ra một chữ ký số. Chữ ký số của một bản tin là một giá trị phụ thuộc vào bản tin đó và một khóa bí mật nào đó. Chữ ký số có thể được sử dụng để xác minh nguồn gốc và tính toàn vẹn của bản tin. Trong ứng dụng này, giá trị băm của bản tin được mã hóa bằng khóa bí mật của người gửi. Bất kỳ ai biết khóa công khai tương ứng của người gửi đều có thể xác minh chữ ký số.\n\n**Các ứng dụng khác**\nHàm băm còn được sử dụng trong các ứng dụng khác như tạo mật khẩu một chiều, phát hiện xâm nhập và phát hiện virus."
            },
            {
              "level_3_title": "4.1.2. Các yêu cầu và độ an toàn hàm băm",
              "level_3_id": "4.1.2",
              "content": "Để hiểu rõ yêu cầu và an toàn của hàm băm, ta cần định nghĩa hai điều kiện. Đối với giá trị băm h = H(x), x được gọi là nghịch ảnh của h. Nghĩa là x là một khối dữ liệu có hàm băm là h sử dụng hàm H. Vì hàm H là phép ánh xạ từ nhiều phần tử thành một, nên với một giá trị h cho trước, có thể tạo ra nhiều nghịch ảnh. Một xung đột xảy ra nếu x khác y và H(x) = H(y). Do chúng ta sử dụng các hàm băm để đảm bảo tính toàn vẹn của dữ liệu nên các xung đột là điều không mong muốn.\nGiả sử rằng, độ dài của giá trị băm là n bit và hàm H có các bản tin đầu vào hay các khối dữ liệu có độ dài b bit (b > n). Khi đó, tổng số bản tin có thể là 2^b và tổng số các giá trị băm là 2^n. Trung bình, mỗi giá trị băm tương ứng với 2^(b – n) nghịch ảnh. Trên thực tế, nếu H phân bố đều các giá trị băm thì mỗi giá trị băm sẽ có xấp xỉ 2^(b – n) nghịch ảnh.\n\n**Các yêu cầu bảo mật cho các hàm băm bảo mật**\nBảng 4.1 liệt kê các yêu cầu được chấp nhận chung cho một hàm băm mã hóa. Ba yêu cầu đầu tiên được áp dụng cho các ứng dụng thực tế của hàm băm. Yêu cầu thứ tư, chống nghịch ảnh, là một đặc tính một chiều, nghĩa là: một mã băm có thể dễ dàng tạo ra bởi một bản tin cho trước nhưng hầu như không có khả năng tái tạo lại bản tin thông qua một mã băm cho trước. Đặc tính này vô cùng quan trọng nếu các kỹ thuật xác thực sử dụng các giá trị bí mật. Giá trị bí mật không được gửi đi nhưng nếu hàm băm không phải là hàm một chiều thì kẻ tấn công có thể dễ dàng phát hiện ra được giá trị bí mật. Nếu kẻ tấn công có thể quan sát hoặc chặn một đường truyền, kẻ tấn công có thể thu được bản tin M và mã băm h = H(S || M). Sau đó, kẻ tấn công có thể triển khai ngược hàm băm để lấy được S||M = H^-1(h). Do bây giờ, kẻ tấn công có cả M và S||M, nên có thể dễ dàng tìm ra được S.\nBảng 4.1: Các yêu cầu hàm băm bảo mật\n- Kích thước biến đầu vào: H có thể ứng dụng cho một khối dữ liệu có kích thước.\n- Kích thước đầu ra cố định: H tạo ra đầu ra có độ dài cố định.\n- Hiệu quả: H(x) dễ dàng tính toán cho một x bất kỳ cho trước, có thể triển khai trên cả phần cứng và phần mềm.\n- Tính chất một chiều: Với bất kỳ giá trị băm h, tính toán y để H(y)=h là bất khả thi.\n- Kháng xung đột yếu: Với bất kỳ một khối x, tính toán để tìm y khác x với H(y)=H(x) là bất khả thi.\n- Kháng xung đột mạnh: Bất khả thi trong tính toán tìm kiếm một cặp bất kỳ (x,y) để H(y)=H(x).\n- Giả ngẫu nhiên: Đầu ra của H đảm bảo tính giả ngẫu nhiên\nĐặc tính thứ năm, chống nghịch ảnh bậc 2, đảm bảo việc không thể tìm được một bản tin thay thế với giá trị băm của bản tin cho trước. điều này ngăn chặn sự giả mạo khi mã băm mã hóa được sử dụng. Nếu đặc tính này không thỏa mãn, kẻ tấn công có khả năng thực hiện các hành động sau đây: Đầu tiên, quan sát hoặc chặn một bản tin cùng với mã băm mã hóa của nó; tiếp theo, tạo một mã băm không mã hóa từ bản tin; cuối cùng, tạo ra bản tin thay thế với mã băm tương tự.\nHàm băm thỏa mãn năm đặc tính đầu tiên được xem như hàm băm yếu. Nếu đặc tính thứ sáu, chống xung đột, thỏa mãn thì hàm băm đó được gọi là hàm băm mạnh. Một hàm băm mạnh có khả năng chống lại tấn công trong dó một bên tạo ra bản tin cho một bên khác ký.\n\n**Các tấn công đoán thử đúng sai**\nĐối với các thuật toán mã hóa thường có hai loại tấn công nhằm vào hàm băm là: Tấn công đoán thử đúng sai và giải mã. Tấn công đoán thử đúng sai không phụ thuộc vào một thuật toán cụ thể mà chỉ phụ thuộc vào độ dài bit. Trong trường hợp của hàm băm, tấn công đoán thử đúng sai chỉ phụ thuộc vào độ dài của giá trị băm. Ngược lại, giải mã là tấn công dựa trên các điểm yếu trong một thuật toán mã hóa cụ thể nào đó.\n\n**Tấn công vào nghịch ảnh và nghịch ảnh bậc hai**\nĐối với tấn công vào nghịch ảnh hoặc nghịch ảnh bậc hai, kẻ tấn công muốn tìm một giá trị y theo hàm H(y) có giá trị bằng giá trị băm h cho trước. Phương pháp tấn công đoán thử đúng sai sẽ chọn giá trị y ngẫu nhiên và thử cho đến khi xung đột xảy ra. Đối với một giá trị băm m-bit, số phép thử tỉ lệ với 2^m. Nghĩa là, kẻ tấn công cần phải thử 2^(m-1) giá trị y để tìm ra một giá trị chính xác.\n\n**Tấn công vào chống xung đột**\nĐối với tấn công vào đặc tính chống xung đột, kẻ xấu muốn tìm hai bản tin hoặc các khối dữ liệu x và y, có cùng một hàm băm H(x) = H(y). Tấn công này cần ít phép đoán thử hơn so với tấn công vào nghịch ảnh và nghịch ảnh bậc hai. Về cơ bản, nếu các biến ngẫu nhiên được phân bố đều trong dải từ 0 đến N-1 thì xác suất để một phần tử lặp lại vượt quá 0.5 sau sqrt(N) lựa chọn được thực hiện. Do đó, đối với giá trị băm m-bit, nếu các khối dữ liệu được chọn một cách ngẫu nhiên thì có thể tìm thấy hai khối dữ liệu có cùng giá trị băm sau 2^(m/2) phép thử."
            }
          ]
        },
        {
          "level_2_title": "4.2. Mã xác thực bản tin MAC",
          "level_2_id": "4.2",
          "children": [
            {
              "level_3_title": "4.2.1. Các yêu cầu xác thực bản tin",
              "level_3_id": "4.2.1",
              "content": "Trong ngữ cảnh bản tin chuyển xuyên suốt qua mạng truyền thông, có thể tồn tại các loại tấn công sau đây:\n1. Tấn công tiết lộ (disclosure): Phân phối nội dung bản tin tới bất kỳ cá nhân hoặc đối tượng không sở hữu khóa mật mã phù hợp.\n2. Phân tích lưu lượng: Tìm hiểu mẫu lưu lượng giữa hai bên truyền thông. Trong một ứng dụng hướng kết nối, tần suất và khoảng thời gian kết nối có thể được xác định. Trong một môi trường hướng kết nối hoặc phi kết nối, số lượng và chiều dài bản tin giữa các bên truyền thông có thể được xác định.\n3. Ngụy trang: Đưa thông tin vào các bản tin trong mạng từ nguồn giả mạo. Kiểu tấn công này này bao gồm việc tạo các bản tin bởi kẻ tấn công chủ ý đến từ một thực thể được ủy quyền. Nó cũng bao gồm các bản tin báo nhận giả mạo của các bản tin được nhận hoặc không được nhận bởi một người nào đó khác với người nhận đích thực.\n4. Tấn công sửa đổi nội dung: Các thay đổi đối với nội dung của bản tin, bao gồm sự thêm vào, xóa bớt, đổi chỗ và sửa đổi.\n5. Sửa đổi chuỗi: Bất kỳ sự sửa đổi nào đối với chuỗi các bản tin giữa các bên truyền thông, bao gồm việc thêm, bớt và sắp xếp lại thứ tự.\n6. Sửa đổi định thời: Làm trễ hoặc phát lại các bản tin. Trong một ứng dụng hướng kết nối, toàn bộ một phiên hoặc chuỗi các bản tin có thể là một bản phát lại của một vài phiên hợp lệ trước đó hoặc các bản tin riêng biệt trong chuỗi các bản tin có thể bị trễ hoặc bị phát lại. Trong một ứng dụng phi kết nối, một bản tin riêng biệt (ví dụ như một datagram) có thể bị trễ hoặc phát lại.\n7. Chối bỏ nguồn: Chối bỏ sự truyền dẫn của bản tin do nhầm lẫn nguồn.\n8. Chối bỏ đích: Chối bỏ sự truyền dẫn của bản tin do sai đích.\nCác phương pháp đối phó với hai loại tấn công đầu nằm trong khuôn khổ của bảo mật bản tin. Các giải pháp cho các loại tấn công từ số (3) đến (6) liên quan tới nhận thực bản tin. Các cơ chế đối phó với tấn công số (7) đi theo hướng chữ ký số. Nói chung, một kỹ thuật chữ ký số cũng sẽ giúp đối phó với một vài hoặc tất cả các loại tấn công từ (3) dến (6). Để giải quyết vấn đề số (8) có thể cần tới một sự kết hợp giữa chữ ký số và một giao thức bảo mật. Như vậy, nhận thực bản tin là một thủ tục để xác thực rằng các bản tin được nhận đến từ đúng nguồn và không bị sửa đổi hoặc thay thế. Chữ ký số là một kỹ thuật nhận thực bao gồm cả các giải pháp đối phó với sự chối bỏ nguồn."
            },
            {
              "level_3_title": "4.2.2. Chức năng xác thực bản tin",
              "level_3_id": "4.2.2",
              "content": "Bất kỳ một cơ chế nhận thực bản tin hoặc chữ ký số nào đều có hai lớp chức năng. Tại lớp chức năng thấp, cần phải có một vài loại chức năng cung cấp một ký hiệu xác nhận: một giá trị được sử dụng để nhận thực. Chức năng lớp thấp này sau đó được sử dụng như là một yếu tố cơ bản cho một giao thức nhận thực lớp cao để cho phép bên nhận xác minh tính xác thực của một bản tin.\nCác hàm này có thể được phân làm ba loại:\n+ Hàm băm: Một hàm ánh xạ một bản tin với độ dài bất kỳ vào một giá trị băm có chiều dài cố định, giá trị này là ký hiệu nhận thực.\n+ Mã hóa bản tin: Từ mã của toàn bộ bản tin là kỹ hiệu nhận thực của bản tin đó.\n+ Mã xác thực bản tin (MAC): Một hàm của bản tin và khóa bí mật tạo ra giá trị có chiều dài cố định có chức năng như một ký hiệu xác thực.\n\n**Mã hóa bản tin**\nBằng chính mã hóa của bản tin có thể cung cấp một giải pháp cho vấn đề nhận thực và khác nhau đối với các cơ chế mã hóa khóa đối xứng và khóa công khai.\nMã hóa khóa đối xứng: Xét một trường hợp sử dụng khóa đối xứng đơn giản. Một bản tin M được truyền từ nguồn A tới đích B được mã hóa sử dụng khóa bí mật K được chia sẻ giữa A và B. Nếu không có bên nào khác biết khóa này, tính bảo mật được đảm bảo: Không có một bên nào khác có thể thấy được nội dung bản tin. Thêm vào đó, B được đảm bảo rằng bản tin được tạo ra bởi A. Bản tin phải được gửi từ A, bởi vì A là bên duy nhất sở hữu khóa K, và do đó là bên duy nhất có thông tin cần thiết để tạo ra bản mã mà có thể được giải mã bằng K. Hơn nữa, nếu M được khôi phục lại, B biết rằng không có bit nào của M bị thay thế, do một kẻ tấn công không biết khóa K có thể biết được làm cách nào để thay thế các bit trong bản mã để tạo ra sự thay đổi như mong muốn trong bản rõ.\nDo vậy chúng ta nói rằng mã hóa đối xứng cung cấp sự nhận thực cũng như là tính bảo mật. Tuy nhiên, tuyên bố này cần có đủ điều kiện. Xem xét những gì xảy ra tại B. Cho trước một hàm giải mã D và khóa bí mật K, bên nhận sẽ chấp nhận bất kỳ đầu vào X nào và đưa ra đầu ra Y = D(K,X). Nếu X là bản mã của của một bản tin hợp pháp M được tạo ra bởi hàm mã hóa tương ứng, khi đó Y là một bản tin mã hóa nào đó. Ngược lại, Y có thể là một chuỗi bit vô nghĩa. Có thể cần một vài cách kiểm tra tự động để xác định xem Y có phải là bản rõ hợp pháp không và do đó có đến từ A hay không. Ngụ ý sâu xa của đoạn trên là từ góc nhìn của nhận thực. Trong trường hợp đó, không có cách nào để xác định một cách tự động, tại đích, để đánh giá xem một bản tin đến là bản mã của một bản tin hợp pháp hay không. Điều kết luận sau đây là không thể chối cãi: Nếu M có thể là bất kỳ mẫu bit nào, khi đó bất kỳ giá trị nào của X, giá trị Y = D(K,X) là một mẫu bit nào đó và do đó phải được chấp nhận là một bản rõ xác thực. Do vậy, một cách tổng quát, chúng ta yêu cầu chỉ có một tập con của tất cả các trường hợp của mẫu bit được xem là bản rõ hợp pháp.\nMột giải pháp cho vấn đề này là buộc bản rõ có một cấu trúc nhất định nào đó mà có thể dễ dàng ghi nhận nhưng không thể sao chép mà không dựa vào hàm mã hóa. Ví dụ, chúng ta có thể thêm vào một mã phát hiện lỗi, còn được gọi là một chuỗi kiểm tra khung (FCS – Frame Check Sequence) hoặc tổng kiểm tra, đối với mỗi bản tin M trước khi mã hóa. A chuẩn bị một bản rõ M sau đó sử dụng nó làm đầu vào của một hàm F có để tạo đầu ra là FCS. FCS được thêm vào M thành một khối và toàn bộ khối này được mã hóa. Tại phía nhận, B giải mã khối tin nhận được và xử lý đầu ra như là một bản tin với phần FCS được thêm vào. B sử dụng cùng một hàm F để tạo lại FCS của bản tin sau giải mã. Nếu giá trị FCS này giống với giá trị FCS được gửi đến thì bản được xem là xác thực. Cần lưu ý rằng thứ tự thực hiện của FCS và các hàm mã hóa là rất quan trọng. Với điều khiển lỗi bên trong, sự nhận thực được cung cấp do một kẻ tấn công có thể (rất hiếm khi) tạo ra được bản mã mà khi giải mã, có các bit điều khiển lỗi hợp lệ.\n\n**Mã hóa khóa công khai**\nMột trường hợp đơn giản sử dụng mã hóa khóa công khai cung cấp tính bảo mật nhưng không cung cấp nhận thực. Nguồn (A) sử dụng khóa công khai PUb của phía nhận (B) để mã hóa bản tin M. Do chỉ có B sở hữu khóa bí mật PRb tương ứng, chỉ có B có thể giải mã bản tin. Cơ chế này không cung cấp nhận thực, vì bất kỳ kẻ tấn công nào cũng có thể sử dụng khóa công khai của B để mã hóa một bản tin và mạo danh A.\nĐể cung cấp sự nhận thực, A sử dụng khóa bí mật của nó để mã hóa bản tin và B sử dụng khóa công khai của A để giải mã. Điều này cung cấp tính nhận thực sử dụng cùng một cách suy luận như trong trường hợp mã hóa khóa đối xứng. Thêm nữa, với cùng cách suy luận: Phải có một cấu trúc bên trong nào đó đối với bản rõ nhờ đó bên nhận có thể phân biệt giữa bản rõ và các bit ngẫu nhiên. Giả sử rằng tồn tại một cấu trúc như vậy, khi đó cơ chế này không cung cấp nhận thực cũng như chức năng tương tự như chữ ký số. Chỉ A có thể cấu trúc nên bản mã bởi vì chỉ có A sở hữu PRa. Thậm chí B, phía nhận, cũng không thể cấu trúc nên bản mã. Do đó, nếu B sở hữu bản mã, B có các phương tiện để chứng minh bản tin phải đến từ A. Thực vậy, A đã “ký” vào bản tin bằng cách sử dụng khóa bí mật của nó để mã hóa. Lưu ý rằng cơ chế này không cung cấp tính bảo mật. Bất kỳ ai sở hữu khóa công khai của A đều có thể giải mã bản mã. Để cung cấp cả tính bảo mật và nhận thực, đầu tiên A mã hóa M sử dụng khóa bí mật của nó để tạo chữ ký số, sau đó sử dụng khóa công khai của B để cung cấp tính bảo mật. Nhược điểm của tiếp cận này là thuật toán khóa công khai là thuật toán phức tạp cần được thực hiện bốn lần chứ không phải hai lần trong mỗi (phiên) truyền thông.\n\n**Mã xác thực bản tin**\nMột kỹ thuật nhận thực khác liên quan đến việc sử dụng khóa bí mật để tạo khối dữ liệu nhỏ có kích thước cố định, được biết đến như là tổng kiểm tra mã hóa hoặc MAC, được thêm vào bản tin. Kỹ thuật này giả thiết hai bên tham gia truyền thông, giả sử là A và B, chia sẻ một khóa bí mật chung là K. Khi A có bản tin cần gửi tới B, nó tính MAC là hàm của bản tin và khóa:\nMAC = C(K, M)\nTrong đó: M là bản tin đầu vào, C là hàm MAC, K là khóa bí mật chia sẻ, MAC là mã xác thực bản tin.\nBản tin cùng với MAC được truyền tới người nhận mong muốn. Người nhận thực hiện các thao tác tương tự đối với bản tin đến, sử dụng cùng một khóa bí mật, để tạo một giá trị MAC mới. Giá trị MAC nhận được được so sánh với MAC được tính lại. Nếu ta giả sử chỉ có duy nhất bên nhận và bên gửi biết khóa chia sẻ, và MAC nhận được khớp với MAC được tính, khi đó:\n1. Bên nhận được đảm bảo rằng bản tin đã không bị thay đổi.\n2. Bên nhận được đảm bảo rằng bản tin đến từ đúng người gửi.\n3. Nếu bản tin bao gồm một số thứ tự (như được sử dụng trong HDLC, X.25, và TCP), khi đó người nhận có thể được đảm bảo số thứ tự đó là đúng bởi vì một kẻ tấn công không thể thay đổi được số thứ tự.\nMột hàm MAC tương tự với mã hóa. Một điểm khác biệt là thuật toán MAC cần phải không thể nghịch đảo, vì nó phải dùng cho giải mã. Tổng quát, hàm MAC là hàm nhiều-tới-một. Miền của hàm bao gồm các bản tin có độ dài tùy ý, trong khi khoảng giá trị bao gồm tất cả các MAC có thể và tất cả các khóa có thể.\nCó ba tình huống trong đó mã xác thực bản tin được sử dụng:\n1. Có một số các ứng dụng trong đó cùng một bản tin được phát quảng bá tới một số lượng các điểm đích. Nó rẻ hơn và đáng tin cậy hơn so với việc chỉ có một đích đến có trách nhiệm giám sát tính xác thực.\n2. Kịch bản khác cần đến nhận thực là khi có một trao đổi trong đó một bên có chịu tải nặng và không đủ thời gian để giải mã tất cả các bản tin đến. Việc chứng thực được thực hiện dựa trên một số cơ sở được chọn lọc, các bản tin được chọn ngẫu nhiên để kiểm tra.\n3. Nhận thực một chương trình máy tính dưới dạng bản rõ là một dịch vụ hấp dẫn. Chương trình máy tính có thể được thực hiện mà không cần phải giải mã liên tục – gây lãng phí tài nguyên bộ xử lý. Tuy nhiên, nếu một mã xác thực bản tin được đính kèm vào chương trình, nó có thể được kiểm tra khi có yêu cầu về tính toàn vẹn của chương trình.\n4. Đối với một vài ứng dụng, có thể không quan tâm tới việc giữ bí mật cho các bản tin, nhưng nhận thực bản tin là quan trọng.\n5. Sự phân chia các chức năng nhận thực và bảo mật giúp tạo tính linh động trong kiến trúc.\n6. Một người dùng muốn kéo dài khoảng thời gian bảo vệ vượt ra ngoài thời gian nhận và chưa cho phép xử lý nội dung bản tin.\nCuối cùng, lưu ý MAC không cung cấp chữ ký số, do cả bên gửi và bên nhận đều chia sẻ cùng một khóa."
            },
            {
              "level_3_title": "4.2.3. Các yêu cầu cho mã xác thực bản tin",
              "level_3_id": "4.2.3",
              "content": "Một mã xác thực bản tin (MAC) được biết đến như là một tổng kiểm tra mã hóa, được tạo bởi hàm C theo dạng: MAC = C(K,M). Trong đó M là bản tin có độ dài thay đổi, K là khóa bí mật được chia sẻ chỉ bởi người gửi và người nhận, và MAC(K, M) là ký hiệu nhận thực có chiều dài cố định, đôi khi được gọi là nhãn. Nhãn được thêm vào bản tin ở nguồn tại thời điểm mà bản tin được đảm bảo hoặc được xem là đúng. Bên nhận nhận thực bản tin này bằng cách tính lại nhãn.\nKhi toàn bộ bản tin được mã hóa để đảm bảo tính bảo mật, sử dụng mã hóa đối xứng hoặc bất đối xứng, tính bảo mật của cơ chế nói chung phụ thuộc vào chiều dài chuỗi bit khóa. Dựa vào một vài điểm yếu trong thuật toán, kẻ địch phải phải dùng đến tấn công vét cạn để tìm tất cả các khóa có thể có. Tính trung bình, một tấn công như vậy sẽ cần đến 2^(k-1) truy nhập đối với khóa k-bit. Đặc biệt, đối với tấn công chỉ với bản mã, kẻ tấn công, cho trước bản mã C, thực hiện Pi = D(Ki, C) đối với tất cả các giá trị khóa có thể Ki cho tới khi một Pi được tạo ra khớp với dạng có thể chấp nhận được của bản rõ.\nTrong trường hợp của MAC, vấn đề quan tâm là hoàn toàn khác khi hàm MAC là hàm nhiều-tới-một. Sử dụng các phương pháp vét cạn, làm sao để một kẻ địch có thể khám phá ra một khóa? Nếu tính bảo mật không được sử dụng, kẻ tấn công có được bản rõ và giá trị MAC tương ứng của nó. Giả sử k > n; nghĩa là, giả sử kích thước khóa lớn hơn kích thước MAC. Khi đó, cho trước M1 và T1 đã biết, với T1 = MAC(K, M1), bộ mã hóa (cryptanalyst) có thể thực hiện Ti = MAC(Ki, M1) đối với tất cả các giá trị khóa ki có thể có. Ít nhất một khóa đảm bảo tạo ra được giá trị trùng khớp Ti=T1. Lưu ý rằng tổng số 2^k nhãn sẽ được tạo ra, nhưng chỉ có 2^n < 2^k giá trị nhãn khác nhau. Do vậy, một số khóa sẽ tạo ra nhãn đúng và kẻ tấn công không thể biết đâu là khóa đúng. Tính trung bình, tổng cộng 2^(k-n) khóa sẽ tạo ra một trường hợp trùng khớp. Do đó, kẻ địch phải lặp lại các tấn công nhiều lần.\nDo vậy, một tấn công vét cạn cố gắng để khám phá khóa nhận thực cần không ít tính toán hơn so với việc yêu cầu khám phá khóa giải mã có cùng chiều dài. Tuy nhiên, các tấn công khác mà không yêu cầu khám phá khóa có thể xảy ra.\nDo vậy, trong việc đánh giá tính an ninh của một hàm MAC, chúng ta cần xét các loại tấn công có thể được thực hiện. Từ đó, ta sẽ đưa ra các yêu cầu đối với hàm. Giả sử rằng một kẻ tấn công biết hàm MAC nhưng không biết K. Khi đó hàm MAC cần thỏa mãn những yêu cầu sau:\n1. Nếu một kẻ tấn công quan sát M và MAC(K,M), sẽ là không khả thi với kẻ tấn công nếu tạo một bản tin M’ thỏa mãn: MAC(K,M) = MAC(K,M’)\n2. MAC(K,M) nên có phân bố chuẩn đối với các bản tin được lựa chọn ngẫu nhiên, M và M’, xác suất để MAC(K,M) = MAC(K,M’) là 2^-n, trong đó n là số bit trong nhãn.\n3. Cho M’ là kết quả của sự chuyển đổi nào đó của M, M’=f(M).Ví dụ, f có thể là một số thao tác nghịch đảo một hoặc nhiều bit. Khi đó: Pr[MAC(K,M) = MAC(K,M’)] = 2^-n\nYêu cầu thứ nhất phát biểu đối cho ví dụ trước đó, trong đó một kẻ tấn công có khả năng tạo ra một bản tin mới để khớp với một nhãn cho trước, ngay cả khi kẻ tấn công không biết và không cần tìm hiểu khóa. Yêu cầu thứ hai dựa vào yêu cầu cần một tấn công vét cạn dựa trên bản rõ cho trước. Nghĩa là, nếu ta giả sử kẻ địch không biết K nhưng có thể tiếp cận được hàm MAC và có thể chỉ định các bản tin cho bộ tạo MAC, sau đó kẻ địch có thể thử nhiều bản tin khác nhau có tới khi tìm ra bản tin khớp với nhãn cho trước. Yêu cầu cuối cùng đòi hỏi thuật toán nhận thực không nên yếu hơn ở một số phần hoặc bit nhất định so với các phần khác hoặc bit khác. Ngược lại, khi đó một kẻ tấn công có M và MAC(K,M) có thể thực hiện thay dổi đối với M tại điểm yếu và nhiều khả năng thành công sớm trong việc tạo ra bản tin khớp với nhãn cũ."
            },
            {
              "level_3_title": "4.2.4. Tính an toàn của MAC",
              "level_3_id": "4.2.4",
              "content": "Nếu chỉ dựa vào các thuật toán mã hóa và các hàm băm, ta có thể phân nhóm các tấn công vào MAC thành hai nhóm: Các tấn công vét cạn và phân tích mã hóa.\n\n**Các tấn công vét cạn**\nMột tấn công vét cạn đối với MAC khó thực hiện hơn so với tấn công vét cạn vào hàm băm bởi vì nó yêu cầu biết trước các cặp bản tin-nhãn. Để tấn công một mã băm, ta có thể làm theo cách sau: Cho trước một bản tin cố định x với mã băm n bit h=H(x), một phương pháp vét cạn tìm kiếm xung đột là chọn một chuỗi bit ngẫu nhiên y và kiểm tra đẳng thức H(y)=H(x). Kẻ tấn công có thể lặp lại phép thử này ngoại tuyến. Việc một tấn công ngoại tuyến có thể được sử dụng đối với thuật toán MAC hay không phụ thuộc vào kích thước tương đối của khóa và nhãn. Để tiến hành, ta cần đưa ra đặc tính an ninh mong muốn của một thuật toán MAC được phát biểu như sau:\nChống lại tính toán: Cho trước một hoặc nhiều cặp bản rõ MAC, [xi, MAC(K, xi)], việc tính bất kỳ cặp bản rõ MAC, [x, MAC(K, x)] đều là không khả dụng với bất kỳ đầu vào mới x khác xi nào.\nNói cách khác, kẻ tấn công muốn khám phá mã MAC có hiệu lực đối với bản tin x cho trước. Có hai loại tấn công có thể xảy ra: tấn công không gian khóa và tấn công giá trị MAC.\nNếu một kẻ tấn công có thể xác định khóa MAC, khi đó hắn có thể tạo một giá trị MAC hợp lệ đối với bất kỳ đầu vào x nào. Giả sử kích thước khóa k bit và kẻ tấn công biết trước một cặp bản rõ-nhãn. Khi đó kẻ tấn công có thể tính toán nhãn n bit đối với bản rõ đã biết với tất cả các khóa có thể. Ít nhất một khóa đảm bảo tạo ra nhãn đúng, khóa đúng ban đầu được sử dụng để tạo ta cặp bản rõ-nhãn đã biết. Giai đoạn tấn công này sử dụng mức cố gắng tương đương với 2^k (có nghĩa là, một thao tác thực hiện với mỗi một trong 2^k giá trị khóa). Tuy nhiên, như đã được miêu tả trước đó, do MAC là ánh xạ nhiều tới-một, có thể có các khóa khác tạo ra được đúng đầu ra. Do vậy, nếu có nhiều hơn một khóa được tìm thấy có thể tạo ra giá trị đúng, các cặp bản rõ-nhãn thêm vào cần phải được kiểm tra. Có thể thấy rằng mức độ nỗ lực là vào khoảng 2^k lần thử.\nMột kẻ tấn công cũng có thể tập trung vào nhãn mà không cần tạo lại khóa. Ở đây, mục tiêu là tạo ra nhãn hợp lệ đối với bản tin cho trước hoặc tìm ta một bản tin khớp với nhãn cho trước. Trong mỗi trường hợp, mức độ cố gắng là có thể so sánh được đối với trường hợp tấn công đặc tính một chiều hoặc chống chịu xung đột kém của mã băm, hoặc 2^n. Trong trường hợp của MAC, tấn công không thể tiến hành trong điều kiện ngoại tuyến mà không có thêm dầu vào; kẻ tấn công sẽ cần các cặp bản rõ-nhãn được chọn hoặc thông tin về khóa.\nTổng kết, mức độ nỗ lực đối với tấn công vét cạn vào thuật toán MAC có thể được tính bằng min(2^k, 2^n). Độ mạnh được đánh giá là tương đương đối với các thuật toán mã hóa đối xứng nên lựa chọn hợp lý là chiều dài khóa và nhãn thỏa mãn mối quan hệ min(k,n) >= N với N nằm trong khoảng 128 bit.\n\n**Phân tích mã**\nNhư đối với các thuật toán mã hóa và các hàm băm, các tấn công phân tích mã đối với MAC tìm kiếm để khai thác đặc tính nào đó của thuật toán để thực hiện một tấn công nào đó được cho là phổ biến hơn là tìm kiếm vét cạn. Phương thức để đo lường khả năng chống chịu của một thuật toán MAC đối với tấn công phân tích mã là so sánh với nỗ lực yêu cầu đối với một tấn công vét cạn. Nghĩa là, một thuật toán MAC lý tưởng sẽ yêu cầu một nỗ lực phân tích mã lớn hơn hoặc bằng nỗ lực tấn công vét cạn."
            },
            {
              "level_3_title": "4.2.5. MAC dựa trên hàm băm HMAC",
              "level_3_id": "4.2.5",
              "content": "Phần này chúng ta sẽ xem xét các ví dụ của MAC dựa trên việc sử dụng mã khối đối xứng. Theo truyền thống, đây là tiếp cận chung nhất để cấu trúc nên một MAC. Trong nhưng năm gần đây, sự quan tâm đã tăng lên đối với việc phát triển một MAC nhận được từ hàm băm mã hóa. Động lực của mối quan tâm này là:\n+ Các hàm băm mã hóa như là MD5 hay SHA nói chung thực hiện nhanh hơn trong phần mềm so với mã khối đối xứng như DES.\n+ Thư viện mã cho các hàm băm mã hóa được phổ biến rộng rãi.\nMột hàm băm như SHA không được thiết kế cho việc sử dụng như là một MAC và không thể được sử dụng trực tiếp cho mục đích đó, bởi vì nó không dựa trên một khóa bí mật. Đã có một số đề xuất đối vứi việc liên kết một khóa bí mật với một thuật toán băm có sẵn. Tiếp cận đã nhận được nhiều sự ủng hộ nhất là HMAC. HMAC đã được đề xuất trong RFC 2104, đã được chọn như là MAC buộc phải thực hiện cho an ninh IP, và được sử dụng trong các giao thức Internet khác như là SSL. HMAC cũng được đề xuất là một chuẩn NIST.\n\n**Các mục tiêu thiết kế HMAC**\nRFC 2104 liệt kê các mục tiêu thiết kế sau đây của HMAC\n+ Để sử dụng mà không cần sửa đổi các hàm băm có sẵn. Đặc biệt, để sử dụng các hàm băm thực hiện tốt trong phần mềm và mã chương trình là miễn phí và phổ biến.\n+ Để cho phép khả năng thay thế các hàm băm được nhúng nếu các hàm băm khác nhanh hơn hoặc bảo mật hơn được tìm ra hoặc yêu cầu.\n+ Để kế thừa hiệu năng ban đầu của hàm băm mà không gây ra sự suy giảm đáng kể.\n+ Để sử dụng và xử lý khóa theo một cách đơn giản.\n+ Để có được các phân tích mã hóa dễ hiểu về độ mạnh của của cơ chế nhận thực dựa trên các giả thiết hợp lý về hàm băm được nhúng.\nHai mục tiêu đầu tiên là quan trọng đối với khả năng chấp nhận HMAC. HMAC coi hàm băm như là một “hộp đen” và đem lại hai lợi ích. Đầu tiên, một sự thực hiện có sẵn của một hàm băm có thể được sử dụng như là một mô-đun trong thực thi HMAC. Theo cách này, cụm mã HMAC được đóng gói trước và sẵn sàng được sử dụng mà không cần sửa đổi. Thứ hai, khi muốn thay thế một hàm băm cho trước trong sự thực thi HMAC, tất cả những gì được yêu cầu là loại bỏ môđun hàm băm có sẵn và đưa môđun mới vào. Điều này có thể được thực hiện nếu muốn một hàm băm nhanh hơn. Quan trọng hơn, nếu an ninh ninh của hàm băm được nhúng bị xâm hại, an ninh của HMAC có thể được giữ lại chỉ đơn giản bằng cách thay thế hàm băm được nhúng bằng một hàm băm an ninh toàn hơn (ví dụ thay thế SHA-2 bằng SHA-3).\n\n**Thuật toán HMAC**\nHình 4.6 minh họa hoạt động của HMAC. Định nghĩa các thuật ngữ sau:\nH = hàm băm được nhúng (ví dụ MD5, SHA-1, RIPEMD-160)\nIV = giá trị khởi tạo đầu vào của hàm băm\nM = bản tin đầu vào cho HMAC (bao gồm phần đệm xác định trong hàm băm được nhúng)\nYi = block thứ i của M, 0 <= i <= L - 1\nL = số block trong M\nb = số bit trong một block\nn = chiều dài mã băm được tạo bởi hàm băm được nhúng\nK = khóa bí mật; chiều dài được đề xuất >= n; nếu chiều dài khóa lớn hơn b, khóa là đầu vào của hàm băm để tạo ra một khóa n bit\nK+ = K được đệm vào phía trái để được chiều dài b bit\nIpad = 00110110 (36 trong hệ hexa) được lặp lại b/8 lần\nOpad = 01011100 (5C trong hệ hexa) được lặp lại b/8 lần\nKhi đó HMAC có thể được biểu diễn như sau:\nHMAC(K, M) = H[(K+ XOR opad) || H[(K+ XOR ipad) || M]]\nTa có thể miêu tả thuật toán như sau:\n(1) Thêm các số 0 vào phía cuối bên trái của K để tạo một chuỗi b bit K+ (ví dụ nếu K có chiều dài 160 bit và b = 512 khi đó cần thêm 44 số 0 vào K).\n(2) XOR K+ với ipad để tạo khối b bit Si.\n(3) Thêm M vào Si.\n(4) Sử dụng hàm H cho luồng được tạo ở bước 3.\n(5) XOR K+ với opad để tạo khối b bit So.\n(6) Thêm giá trị băm nhận được ở bước 4 vào So.\n(7) Sử dụng hàm H với luồng được tạo trong bước 6 và đưa ra kết quả.\nLưu ý rằng kết quả của phép XOR với ipad làm đảo một nửa số bit của K. Tương tự, phép XOR với opad làm đảo một nửa số bit của K, với một tập bit khác. Trong thực tế, bằng cách đưa Si và So qua hàm nén của thuật toán băm, ta đã tạo hai khóa từ K theo phương thức ngẫu nhiên giả tạp âm. HMAC nên thực hiện trong thời gian xấp xỉ thời gian hàm băm nhúng đối với các bản tin dài. HMAC thêm ba lệnh của hàm nén băm (với Si và So và khối được tạo ra từ giá trị băm bên trong).\n\n**An ninh của HMAC**\nAn ninh của bất kỳ hàm MAC nào dựa trên hàm băm nhúng đều phụ thuộc vào độ mạnh mã hóa của hàm băm bên dưới theo một cách nào đó. Sự ủng hộ HMAC là do người thiết kế ra nó có khả năng thể chứng minh mối quan hệ chính xác giữa độ mạnh của hàm băm được nhúng và độ mạnh của HMAC. An ninh của một hàm HMAC được biểu diễn tổng quát theo xác suất giả mạo thành công với cùng khoảng thời gian cho trước và số cặp bản tin-mã cho trước được tạo với cùng một khóa. Về cơ bản, đã chứng minh được rằng với một mức độ nỗ lực cho trước (thời gian, các cặp bản tin-nhãn) đối với các bản tin được tạo bởi một người dùng hợp pháp và được theo dõi bởi một kẻ tấn công, xác suất tấn công vào HMAC thành công tương đương với một trong các tấn công sau đây vào hàm băm được nhúng:\n+ Kẻ tấn công có khả năng tính toán một đầu ra của hàm nén ngay cả với một IV ngẫu nhiên, bí mật và kẻ tấn công không biết trước.\n+ Kẻ tấn công tìm các xung đột trong hàm băm ngay cả khi IV là ngẫu nhiên và bí mật.\nTrong tấn công đầu, ta có thể xem hàm nén tương đương với hàm băm áp dụng đối với một bản tin bao gồm một khối b bit đơn. Với tấn công này, IV của hàm băm được thay thế bởi một giá trị bí mật, ngẫu nhiên n bit. Một tấn công vào hàm băm này cần có tấn công vét cạn vào khóa – có mức độ nỗ lực 2^n, hoặc tấn công ngày sinh – là trường hợp đặc biệt của tấn công thứ hai.\nTrong tấn công thứ hai, kẻ tấn công tìm kiếm hai bản tin M và M’ tạo ra cùng giá trị băm H(M)= H(M’) còn gọi là tấn công ngày sinh. Tấn công này yêu cầu nỗ lực 2^(n/2) đối với giá trị băm có chiều dài n."
            },
            {
              "level_3_title": "4.2.7. Mật mã được xác thực",
              "level_3_id": "4.2.7",
              "content": "Mã hóa xác thực AE (Authenticated Encryption) là một thuật ngữ dùng để mô tả các hệ thống mã hóa với mục đích bảo vệ đồng thời cả tính bảo mật và xác thực (toàn vẹn)cho quá trình truyền thông. Nhiều ứng dụng và giao thức yêu cầu cả hai hình thức an ninh này, nhưng cho đến gần đây hai dịch vụ này đã được thiết kế riêng biệt. Có bốn phương pháp chung để cung cấp cả bảo mật và nhận thực cho một bản tin M.\n- Băm sau khi mã hóa (H->E): Đầu tiên tính toán mã hàm băm trên bản tin M bằng h=H(M). Sau đó thực hiện mã hóa bản tin đã được thêm hàm băm: E(K, (M||h)).\n- Xác thực sau khi mã hóa (A->E): Sử dụng hai khóa. Đầu tiên nhận thực bản rõ bằng tính toán giá trị MAC bởi T = MAC(K1, M). Sau đó mã hóa bản tin được thêm mã xác thực bản tin: E(K2, [M||T]). Tiếp cận này được thực hiện bởi các giao thức SSL/TLS.\n- Mã hóa sau khi nhận thực (E->A): Sử dụng hai khóa. Đầu tiên mã hóa bản tin thành bản mã C = E(K2, M). Sau đó xác thực bản mã với T = MAC(K1, C) để tạo thành cặp (C, T). Tiếp cận này được sử dụng trong giao thức IPSec.\n- Độc lập mã hóa và nhận thực (E + A): Sử dụng hai khóa. Mã hóa bản tin thành bản mã C = E(K2, M). Xác thực bản rõ với T = MAC(K1, M) để tạo thành cặp (C, T). Hoạt động này có thể được thực hiện độc lập và được ứng dụng trong giao thức SSH.\nGiải mã và xác thực hoàn toàn được minh bạch trong mỗi phương pháp. Với H->E, A->E và E + A, giải mã trước mới xác nhận. Với E->A, tiến hành xác nhận trước mới giải mã. Cả bốn phương pháp này đều tồn tại lỗ hổng an ninh. Tiếp cận theo H->E được sử dụng trong giao thức WEP nhằm bảo vệ mạng WiFi. Phương pháp này có những nhược điểm cơ bản dẫn đến sự thay thế của giao thức WEP bằng WPA. Tuy vậy, bất kỳ phương pháp nào cũng có thể cung cấp một mức độ an ninh cao nếu có thiết kế phù hợp. Đây là mục tiêu của hai tiếp cận được thảo luận trong phần này, cả hai đã được tiêu chuẩn hóa bởi NIST.\n\n**Bộ đếm với CBC-MAC**\nCơ chế bộ đếm với bản tin mã hóa theo chuỗi khối CCM (Counter with Cipher Block Chainning - Message) được chuẩn hóa bởi NIST để hỗ trợ các yêu cầu an ninh cho mạng cục bộ IEEE 802.11 WiFi, nhưng chúng có thể được sử dụng trong bất kỳ ứng dụng mạng nào yêu cầu mã hóa và nhận thực. CCM là một biến thể của phương pháp mã hóa MAC nhằm thực hiện mã hóa nhận thực, được định nghĩa trong NIST SP 800-38C. Các thành phần then chốt của thuật toán CCM là thuật toán mã hóa AES, chế độ hoạt động CTR và thuật toán nhận thực CMAC. Khóa riêng K được dùng cả mã hóa và thuật toán MAC.\nĐầu vào của quá trình mã hóa CCM bao gồm ba phần tử:\n1. Dữ liệu sẽ được nhận thực và mã hóa. Đây là bản rõ P của khối dữ liệu.\n2. Dữ liệu liên quan A sẽ được nhận thực nhưng không được mã hóa. Ví dụ như tiêu đề của giao thức được truyền chính xác cho đúng loại giao thức sẽ cần phải nhận thực.\n3. Một nonce N được ấn định cho tải và dữ liệu liên quan. Đây là một chuỗi duy nhất và khác nhau trong mỗi trường hợp trong toàn bộ xuyên suốt quá trình liên kết và nhằm ngăn chặn các cuộc tấn công lặp và một số loại tấn công khác.\nHình 4.10 minh họa hoạt động của CCM. Đối với nhận thực, đầu vào bao gồm nonce, dữ liệu liên quan và bản rõ. Đầu vào này được định dạng như một chuỗi các khối từ B0 đến Br. Khối đầu tiên bao gồm nonce được thêm một số bit định dạng biểu thị độ dài của các phần tử N, A và P. Tiếp theo sau là một lượng không âm số khối chứa A và một lượng không âm số khối chứa P. Chuỗi kết quả của khối phục vụ như một đầu vào của thuật toán CMAC, tạo ra giá trị MAC có chiều dài Tlen bé hơn hoặc bằng chiều dài khối (Hình 4.10a).\nVới mã hóa, một chuỗi của bộ đếm được tạo gần như độc lập với nonce. Mã nhận thực được mã hóa trong chế độ CTR sử dụng bộ đếm đơn Ctr0. Các bit quan trọng nhất MSB (Most Significant bits) ở đầu ra được XOR với mã nhận thực để tạo thành một thẻ mã hóa. Phần còn lại của bộ đếm được sử dụng cho chế độ mã hóa CTR của bản rõ. Bản rõ đã mã hóa được nối với thẻ mã hóa để tạo thành các đầu ra cho bản mã (Hình 4.10b).\n\n**Chế độ Galois/bộ đếm**\nChế độ GCM (Galois/Counter Mode) được chuẩn hóa bởi NIST trong NIST SP 800-38D được thiết kế song song để cung cấp thông lượng cao với chi phí và trễ thấp. Về bản chất, bản tin được mã hóa trong biến thể của chế độ CTR. Kết quả của bản mã được nhân với thông tin về khóa và chiều dài bản tin thông qua GF(2^128) để tạo thẻ nhận thực. Các tiêu chuẩn cũng quy định một chế độ hoạt động chỉ cung cấp cho MAC, được gọi là GMAC. Chế độ GMAC tận dụng hai hàm: GHASH là một khóa hàm băm, và GCTR là chế độ thiết yếu với bộ đếm được xác định bởi một số gia đơn giản trong một thao tác."
            }
          ]
        },
        {
          "level_2_title": "4.3. Câu hỏi ôn tập chương 4",
          "level_2_id": "4.3",
          "content": "1. Ứng dụng của hàm băm và các yếu tố ảnh hưởng tới bảo mật của hàm băm\n2. Các đặc trưng và nguyên tắc hoạt động của mã xác thực bản tin\n3. Độ an toàn của mã xác thực bản tin MAC\n4. Đặc trưng cơ bản của mã xác thực bản tin dựa trên hàm băm HMAC\n5. Các phương pháp mã hóa xác thực",
          "children": []
        }
      ]
    },
    {
      "level_1_title": "Chương 5: Xác thực",
      "level_1_id": "5",
      "children": [
        {
          "level_2_title": "5.1. Quản lý và phân phối khóa",
          "level_2_id": "5.1",
          "children": [
            {
              "level_3_title": "5.1.1. Phân phối khóa đối xứng sử dụng mật mã hóa đối xứng",
              "level_3_id": "5.1.1",
              "content": "Đối với phương pháp mã khóa đối xứng, các thành viên chia sẻ cùng một khóa và khóa được bảo vệ bởi các thành phần ngoài. Hơn nữa, khóa được thay đổi thường xuyên nhằm tránh các tấn công. Vì vậy, sức mạnh của bất kỳ một hệ thống mã hóa nào cũng đều liên quan tới kỹ thuật phân phối khóa, một thuật ngữ sử dụng để tạo ra khóa giữa hai thành viên đảm bảo tính bí mật với các bên khác.\nVới hai bên A và B, sự phân phối khóa có thể thực hiện theo một số cách sau:\n1. A lựa chọn một khóa và chuyển phát tới B.\n2. Một thành viên thứ 3 lựa chọn khóa và chuyển phát tới A và B.\n3. Nếu A và B cùng sử dụng một khóa trước đó, một thành viên có thể chuyển một khóa mới dựa trên việc mã hóa khóa cũ.\n4. Nếu A và B có một kết nối mã hóa với một thành viên C, C có thể chuyển phát khóa cho cả A và B.\nTùy chọn 1 và 2 yêu cầu chuyển phát nhân công. Tùy chọn 3 là có thể sử dụng cho mã hóa liên kết hoặc mã hóa từ đầu cuối tới đầu cuối, nhưng nếu một kẻ tấn công thành công trong việc tiếp cận với một khóa thì tất cả các khóa tiếp theo sẽ bị lộ. Hơn nữa, sự phân bố khởi tạo lên đến hàng triệu khóa vẫn phải được thực hiện.\nĐối với mã hóa từ đầu cuối tới đầu cuối, một số biến thể dựa trên tùy chọn 4 được sử dụng rộng rãi. Trong lược đồ này, một trung tâm phân phối khóa chịu trách nhiệm phân phối khóa cho các cặp người dùng (máy chủ, các quy trình, các ứng dụng) khi cần thiết. Mỗi người dùng phải chia sẻ một khóa duy nhất với các trung tâm phân phối khóa.\nỞ mức thấp nhất, hai mức khóa được sử dụng như trên hình 5.2. Truyền thông giữa các đầu cuối được mã hóa bằng một khóa tạm thời, thường được gọi là một khóa phiên. Thông thường, một khoá phiên được sử dụng trong khoảng thời gian của một kết nối logic tồn tại, ví dụ như một kết nối Frame Relay hoặc kết nối truyền tải và sau đó bị loại bỏ. Mỗi khóa phiên thu được từ các trung tâm phân phối khóa trên cùng một hạ tầng truyền thông của mạng. Các khóa phiên được truyền đi trong dạng mã hóa, sử dụng một khóa chủ được chia sẻ bởi các trung tâm phân phối khóa và một hệ thống đầu cuối hoặc người sử dụng. Đối với mỗi hệ thống đầu cuối hoặc người sử dụng, có một khóa chủ duy nhất mà nó chia sẻ với trung tâm phân phối khóa.\n\n**Kịch bản phân phối khóa**\nMột kịch bản điển hình được minh họa trên hình 5.3, với giả thiết mỗi người dùng chia sẻ một khóa chủ duy nhất với trung tâm phân phối khóa KDC (Key Distribution Center). Giả định rằng người dùng A muốn thiết lập một kết nối logic với B và yêu cầu khóa phiên một lần để bảo vệ các dữ liệu được truyền qua kết nối. A có một khóa chủ, Ka, chỉ riêng A và KDC; tương tự, B chia sẻ khóa chủ Kb với KDC. Các bước được thực hiện như sau:\n1. A phát hành yêu cầu đến KDC cho một khóa phiên để bảo vệ một kết nối logic tới B. Bản tin bao gồm nhận dạng của A và B và một định danh duy nhất cho phiên này, N1. N1 được gọi là nonce. Nonce có thể là một tem thời gian, một số đếm, hoặc một số ngẫu nhiên; yêu cầu tối thiểu là phải khác nhau với mỗi yêu cầu.\n2. KDC phản hồi với một bản tin được mã hóa bằng cách sử dụng khóa Ka. Như vậy, A là người duy nhất đọc tin nhắn thành công, và A biết rằng bản tin xuất phát từ KDC. Bản tin gồm hai nội dung dành cho A:\n+ Khóa phiên dùng một lần Ks, sử dụng cho phiên làm việc\n+ Bản tin yêu cầu nguồn gốc bao gồm cả nonce, để cho phép A ghép phản hồi này với yêu cầu thích hợp. Như vậy, A có thể xác minh rằng yêu cầu ban đầu của nó không bị thay đổi trước khi tiếp nhận bởi KDC, từ nonce cho thấy đây không phải là của bản tin phát lại trước đó.\nNgoài ra, bản tin bao gồm hai nội dung dành cho B:\n+ Các khóa phiên một lần Ks, sử dụng cho phiên làm việc\n+ Một nhận dạng của A (ví dụ, địa chỉ mạng của nó), IDA\nHai nội dung cuối được mã hóa với Kb, chúng được gửi đến B để thiết lập kết nối và chứng minh nhận dạng của A.\n3. A lưu trữ khóa phiên cho phiên sắp tới và chuyển tiếp đến B thông tin có nguồn gốc tại KDC cho B, cụ thể là, E (Kb, [Ks || IDA]). Do thông tin này được mã hóa với Kb, nên được bảo vệ khỏi tấn công nghe trộm. B khi đó sẽ biết khóa phiên (Ks), biết bên kia là A (IDA), và biết rằng các thông tin có nguồn gốc tại KDC (vì nó được mã hóa bằng Kb).\nTại thời điểm này, một khóa phiên được chuyển phát an toàn cho A và B cùng với hai bước phụ:\n4. Sử dụng khóa phiên mới được tạo ra để mã hóa, B sẽ gửi một nonce N2 tới A.\n5. Ngoài ra, sử dụng khóa phiên Ks, A trả lời B với f(N2) với f là một hàm thực hiện một số biến đổi trên N2 (ví dụ: cộng một).\nNhững bước này đảm bảo với B rằng bản tin nguyên gốc mà nó nhận được (bước 3) không phải là một bản tin phát lại. Lưu ý rằng việc phân phối khóa thực tế chỉ liên quan đến các bước 1 đến 3, nhưng bước 4 và 5, cũng như bước 3 đều thực hiện chức năng xác thực."
            },
            {
              "level_3_title": "5.1.2. Phân phối khóa đối xứng bằng mật mã hóa bất đối xứng",
              "level_3_id": "5.1.2",
              "content": "Một trong những ứng dụng quan trọng nhất của một hệ thống mật mã khóa công khai là để mã hóa các khóa bí mật. Các nguyên tắc chung được trình bày dưới đây.\n\n**Phân phối khóa bí mật cơ bản**\nMột lược đồ đơn giản được đưa ra bởi Merkle như minh họa trong Hình 5.4. Nếu A muốn truyền thông với B, các thủ tục sau đây được sử dụng:\n1. Tạo ra một cặp khóa công khai / riêng {PUa, PRa} và phát đi một bản tin tới B gồm PUa và định danh của A, IDA.\n2. B tạo ra một khóa bí mật Ks và truyền nó cho A, được mã hóa với khóa công khai của A.\n3. A tính D (PRa, E (PUa, Ks)) để khôi phục lại các khóa bí mật. Bởi vì chỉ có A có thể giải mã bản tin , chỉ có A và B sẽ biết nhận dạng của Ks.\n4. A loại bỏ PUa và PRa và B loại bỏ PUa.\n\n**Phân phối khóa bí mật với nhận thực và bảo mật**\nHình 5.5 chỉ ra một phương pháp phân phối khóa bí mật cung cấp nhận thực và bảo mật. Giả định rằng A và B đã trao đổi khóa công khai theo một lược đồ nào đó, các bước sau sẽ xảy ra.\n1. A sử dụng khóa công khai của B để mã hóa một bản tin đến B có chứa một định danh của A (IDA) và một nonce (N1), được sử dụng để xác định giao dịch duy nhất này.\n2. B gửi một bản tin đến A được mã hóa với PUa và chứa của một nonce (N1) cũng như một nonce mới được tạo ra bởi B (N2). Bởi vì chỉ có B có thể giải mã thông báo (1), sự hiện diện của N1 trong bản tin (2) đảm bảo A rằng trả lời là từ B.\n3. A trả lại N2, mã hóa bằng khóa công khai của B, để đảm bảo B biết đáp ứng đó là từ A.\n4. A chọn một khóa bí mật Ks và gửi M = E (PUb, E (PRa, Ks)) đến B. Bản tin mã hóa này với khóa công khai của B đảm bảo rằng chỉ có B có thể đọc nó; mã hóa với khóa riêng của A đảm bảo rằng chỉ có A có thể gửi bản tin đó.\n5. B tính D (PUa, D (PRb, M)) để khôi phục lại các khóa bí mật.\nKết quả là lược đồ này đảm bảo cả tính bảo mật và xác thực trong việc trao đổi khóa bí mật."
            },
            {
              "level_3_title": "5.1.3. Phân phối khóa công khai",
              "level_3_id": "5.1.3",
              "content": "Một số giải pháp kỹ thuật đã được đề xuất cho việc phân phối khóa công khai có thể nhóm lại thành các loại chung sau:\n+ Thông báo công khai\n+ Thư mục khóa công khai\n+ Trung tâm thẩm quyền khóa công khai\n+ Chứng thư khóa công khai\n\n**Thông báo công khai**\nTheo loại này, điểm của mã hóa khóa công khai là nơi khóa công khai được đưa ra. Nếu thuật toán khóa công khai được chấp thuận rộng rãi như RSA thì bất kỳ một thành viên tham gia có thể gửi khóa công khai của mình cho bất kỳ thành viên tham gia khác (hình 5.6). Mặc dù phương pháp này là thuận tiện nhưng có một nhược điểm lớn là ai cũng có thể giả mạo thông báo công khai như vậy. Một số người dùng có thể giả vờ là người sử dụng A và gửi một khóa công khai cho thành viên khác. Khi người dùng A phát hiện ra sự giả mạo và cảnh báo người tham gia khác thì kẻ giả mạo đã có thể có thể đọc tất cả các bản tin mã hóa dành cho A và có thể sử dụng các khóa giả mạo để xác thực.\n\n**Thư mục khóa công khai**\nMột mức độ cao hơn về an ninh có thể đạt được bằng cách duy trì một thư mục động của khóa công khai. Bảo dưỡng và phân phối thư mục khóa công khai được chịu trách nhiệm của một số thực thể hoặc tổ chức đáng tin cậy (Hình 5.7). Phương pháp này gồm các yếu tố sau:\n1. Người có thẩm quyền duy trì một danh mục với mỗi khoản mục {tên, khóa công khai} cho từng thành viên tham gia.\n2. Mỗi người tham gia đăng ký một khóa công khai với bên thẩm quyển quản lý danh mục. Việc đăng ký thư mục qua các hình thức truyền thông được chứng thực an toàn.\n3. Một người tham gia có thể thay thế khóa bất cứ lúc nào.\n4. Những người tham gia cũng có thể truy cập vào trực tiếp vào thư mục thông qua kênh được nhận thực.\n\n**Trung tâm thẩm quyền khóa công khai**\nĐây là một giải pháp đảm bảo tính an ninh cao hơn giải pháp cung cấp từ thư mục khóa công khai. Một hệ thống điển hình được thể hiện trên hình 5.8. Giải pháp này thực hiện trên một số bước sau:\n1. A gửi một bản tin chứa tem thời gian tới trung tâm thẩm quyền khóa công khai có chứa một yêu cầu khóa công khai của B.\n2. Trung tâm ủy quyền trả lời một bản tin được mã hóa bằng khóa riêng của chính trung tâm, PRauth. Như vậy, A có thể giải mã các bản tin bằng khóa công khai của trung tâm thẩm quyền.\n3. A lưu trữ công khai của B và sử dụng nó để mã hóa một bản tin đến B chứa định danh của A (IDa) và một nonce (N1) để xác định giao dịch duy nhất này.\n4. B thu lấy khóa công khai của A từ trung tâm thẩm quyền theo cách thức tương tự như A lấy khóa công khai của B.\n5. Tại thời điểm này, khóa công khai đã được chuyển giao một cách an toàn để A và B có thể bắt đầu trao đổi các thông tin an toàn. Tuy nhiên, có thể bổ sung hai bước sau:\n6. B gửi một bản tin đến A được mã hóa với PUa và chứa của một nonce (N1) cũng như một nonce mới được tạo ra bởi B (N2). Do chỉ có B có thể có bản tin giải mã (3), sự hiện diện của N1 trong bản tin tại bước (6) đảm bảo rằng A biết trả lời từ B.\n7. A trả lại nounce N2 được mã hóa bằng khóa công khai của B, để B biết rằng bản tin đó đến từ A.\n\n**Chứng thư khóa công khai**\nMột cách tiếp cận khác, lần đầu tiên được đề xuất bởi Kohnfelder sử dụng chứng thư cho những người tham gia để trao đổi các khóa. Về bản chất, một giấy chứng thư bao gồm một khóa công khai, một nhận dạng của chủ sở hữu chính và toàn bộ khối chữ ký của một bên thứ ba đáng tin cậy. Thông thường, các bên thứ ba là một cơ quan cấp chứng thư, chẳng hạn như một cơ quan chính phủ hoặc một tổ chức tài chính, được tin tưởng bởi cộng đồng người dùng. Một người sử dụng có thể gửi khoá công khai tới cơ quan cấp chứng chỉ một cách an toàn và có được một giấy chứng nhận. Người dùng sau đó có thể công bố chứng chỉ. Bất cứ ai cũng cần khóa công khai của người dùng này có thể có được giấy chứng nhận và xác minh rằng nó là hợp lệ bằng chữ ký tin cậy kèm theo. Các thành viên khác có thể xác minh rằng chứng chỉ đã được tạo ra bởi nơi có thẩm quyền."
            },
            {
              "level_3_title": "5.1.4. Chứng thư X.509",
              "level_3_id": "5.1.4",
              "content": "ITU-T đưa ra khuyến nghị X.509 như là một phần của tập tiêu chuẩn X.500 nhằm định nghĩa dịch vụ thư mục. Các thư mục duy trì một cơ sở dữ liệu thông tin về người dùng bao gồm một ánh xạ từ tên người sử dụng, địa chỉ mạng, cũng như các thuộc tính khác và thông tin về người sử dụng. X.509 định nghĩa một khung làm việc cho nhiệm vụ cung cấp dịch vụ chứng thực. Các thư mục có thể phục vụ như là một kho lưu trữ của khóa công khai hoặc chứng chỉ. Ngoài ra, X.509 định nghĩa các giao thức xác thực khác dựa trên việc sử dụng các giấy chứng nhận khóa công khai. Một số phiên bản X.509 được trình bày dưới đây.\n\n**X.509 version 1**\nĐược định nghĩa vào năm 1988, X.509 version 1 giờ đây hầu như không còn được sử dụng.\n\n**X.509 version 2**\nMặc dù chứng chỉ X.509 version 1 cung cấp khá đầy đủ những thông tin cơ bản về người nắm giữa chứng chỉ nhưng nó lại có ít thông tin về tổ chức cấp phát chứng chỉ khi chỉ bao gồm Issuer Name, CA Signature Algorithm và Signature Value. Điều này không giúp dự phòng trong trường hợp CA được thay mới. Khi chứng chỉ của CA được thay mới, trường Issuer Name trong cả 2 chứng chỉ mới và cũ đều như nhau. Tương tự, có thể có một tổ chức khác muốn tạo một CA có trường Issuer Name trong chứng chỉ giống như vậy. Giải quyết vấn đề này để có thể sử dụng lại Issuer Name thì chứng chỉ X.509 version 2 đã được giới thiệu vào năm 1993. Trong định dạng mới có thêm 2 trường chức năng:\n+ Issuer Unique ID: là một trường không bắt buộc, chứa chuỗi giá trị ở hệ 16, mang tính duy nhất và dành để nhận dạng CA. Khi CA thay mới chứng chỉ của chính nó, một Issuer Unique ID mới được khởi tạo cho chứng chỉ đó.\n+ Subject Unique ID: là một trường không bắt buộc, chứa chuỗi giá trị ở hệ 16, mang tính duy nhất và dùng để nhận dạng chủ thể của chứng chỉ. Nếu chủ thể này cũng chính là CA thì trường này sẽ giống với Issuer Unique ID.\n\n**X.509 version 3**\nĐược ra đời vào năm 1996, định dạng X.509 version 3 được bổ sung thêm các phần mở rộng (extension) để khắc phục các vấn đề liên quan tới việc so khớp Issuer Unique ID và Subject Unique ID cũng như là các vấn đề về xác thực chứng chỉ. Một chứng chỉ X.509 version 3 có thể chứa một hoặc nhiều extension, như được thể hiện trong hình dưới đây:\nMỗi extension trong chứng chỉ X.509 version 3 gồm 3 phần:\n+ Extension Identifier: là một mã nhận dạng đối tượng (Object Identifier – OID) cho biết kiểu định dạng và các định nghĩa của extension.\n+ Criticality Flag: là một dấu hiệu cho biết thông tin trong extension có quan trọng (critical) hay không. Nếu một ứng dụng không thể nhận diện được trạng thái critical của extension hoặc extension không hề chứa giá trị nào thì chứng chỉ đó không thể được chấp nhận hoặc được sử dụng. Nếu mục criticality flag này không được thiết lập thì một có thể sử dụng chứng chỉ ngay cả khi ứng dụng đó không nhận diện được extension.\n+ Extension Value: là giá trị được gán cho extension. Nó phụ thuộc vào từng extension cụ thể.\nTrong một chứng chỉ X.509 version 3, các extension sau có thể có là:\n+ Authority Key Identifier: extension này có thể chứa một hoặc hai giá trị, chúng có thể là: Subject Name của CA và Serial Number của chứng chỉ của CA mà đã cấp phát chứng chỉ này; hoặc Giá trị băm của khóa công khai của chứng chỉ của CA mà đã cấp phát chứng chỉ này.\n+ Subject Key Identifier: extension này chứa giá trị băm của khóa công khai của chứng chỉ.\n+ Key Usage: một CA, người dùng, máy tính, thiết bị mạng hoặc dịch vụ có thể sở hữu nhiều hơn một chứng chỉ. Extension này định nghĩa các dịch vụ bảo mật mà một chứng chỉ có thể cung cấp như: Digital Signature, Non-Repudiation, Key Encipherment, Data Encipherment, Key Agreement, Key Cert Sign, CRL Sign, Encipher Only, Decipher Only.\n+ Private Key Usage Period: extension này cho phép khóa bí mật có khoảng thời gian hiệu lực khác so với khoảng thời gian hiệu lực của chứng chỉ.\n+ Certificate Policies: extension này mô tả các chính sách và thủ tục được dùng để xác minh chủ thể của chứng chỉ trước khi chứng chỉ được cấp phát.\n+ Policy Mappings: extension này cho phép chuyển dịch thông tin về chính sách giữa hai tổ chức.\n+ Subject Alternative Name: extension này cung cấp một danh sách các tên thay thế cho chủ thể của chứng chỉ.\n+ Issuer Alternative Name: extension này cung cấp một danh sách các tên thay thế cho CA.\n+ Subject Dir Attribute: extension này có thể bao gồm bất kỳ thuộc tính nào từ danh mục LDAP hoặc X.500 của tổ chức.\n+ Basic Constraints: extension này cho biết chứng chỉ có phải của CA hay của các chủ thể như người dùng, máy tính, thiết bị, dịch vụ.\n+ Name Constraints: extension này cho phép một tổ chức chỉ định không gian tên (namespace) nào được phép hoặc không được phép sử dụng trong chứng chỉ.\n+ Policy Constraints: extension này có thể có trong các chứng chỉ của CA. Nó có thể ngăn cấm Policy Mapping giữa các CA hoặc yêu cầu mỗi chứng chỉ trong chuỗi chứng chỉ phải bao gồm một OID của chính sách chứng chỉ.\n+ Enhanced Key Usage: extension này cho biết khóa công khai của chứng chỉ có thể được sử dụng như thế nào. Những cái này không có trong extension Key Usage.\n+ CRL Distribution Points: extension này chứa một hoặc nhiều URL dẫn tới tập tin chứa danh sách các chứng chỉ đã bị thu hồi (CRL) được phát hành bởi CA.\n+ Authority Information Access: extension này có thể chứa một hoặc nhiều URL dẫn tới chứng chỉ của CA.\n+ Freshest CRL: extension này chứa một hoặc nhiều URL dẫn tới delta CRL do CA phát hành.\n+ Subject Information Access: extension này chứa thông tin cho biết cách thức để truy cập tới các các chi tiết khác về chủ thể của chứng chỉ."
            }
          ]
        },
        {
          "level_2_title": "5.2. Xác thực người sử dụng",
          "level_2_id": "5.2",

          "children": [
            {
              "level_3_title": "5.2.1. Nguyên lí xác thực người sử dụng từ xa",
              "level_3_id": "5.2.1",
              "content": "Trong hầu hết các hoàn cảnh an ninh máy tính, nhận thực người dùng là khối xây dựng cơ bản và là hàng phòng thủ cơ sở. Nhận thực người dùng là cơ sở của hầu hết các loại điều khiển truy nhập và cho trách nhiệm người dùng. RFC 4949 (bảng thuật ngữ an ninh internet) định nghĩa nhận thực người dùng như trình bày trong các trang tiếp theo đây. Ví dụ, người dùng Alice có thể có định danh người dùng ABTOKLAS. Thông tin này cần được lưu trữ trên bất kỳ hệ thống máy chủ hoặc máy tính nào mà Alice muốn dùng và có thể được nhận biết bởi những người quản trị hệ thống và các người dùng khác. Một mục của thông tin nhận thực liên kết với định danh người dùng này là một mật khẩu được giữ bí mật (chỉ được biết bởi Alice và hệ thống). Nếu không ai có thể nhận được hoặc đoán được mật khẩu của Alice, khi đó cặp nhận dạng người dùng-mật khẩu của Alice cho phép người quản trị thiết lập quyền truy nhập của Alice và kiểm tra hoạt động của cô ấy. Do định danh của Alice không bí mật, các người dùng hệ thống có thể gửi cho cô ấy email, nhưng do mật khẩu của cô ấy là bí mật, không ai có thể giả làm Alice.\nVề cơ bản, nhận dạng là phương tiện qua đó một người dùng cung cấp một định danh xác nhận tới hệ thống; nhận thực người dùng là phương tiện thiết lập tính hiệu lực của xác nhận. Lưu ý rằng nhận thực người dùng khác với nhận thực bản tin. Như đã định nghĩa, nhận thực bản tin là một thủ tục cho phép các bên truyền thông xác minh nột dung của bản tin không bị thay đổi và nguồn là xác thực.\nCó bốn phương tiện tổng quát đối với danh tính người dùng có thể được sử dụng độc lập hay kết hợp.\n+ Một vài điều chỉ người dùng bên biết: Ví dụ như mật khẩu, một số nhận dạng cá nhân (Pesonal Identification Number - PIN) hoặc các câu trả lời đối với một tập câu hỏi được sắp xếp trước.\n+ Một vài điều cá nhân sở hữu: Ví dụ như các khóa mật mã, các thẻ khóa điện, các thẻ thông minh và các thể vật lý. Loại phương tiện nhận thực này được xem như một dấu hiệu.\n+ Một vài điều thuộc về bản chất người dùng (các tham số sinh trắc học tĩnh): Ví dụ bao gồm sự xác nhận bằng vân tay, võng mạc và khuôn mặt.\n+ Một vài điều người dùng làm (các tham số sinh trác học động): Các ví dụ bao gồm sự xác nhận bằng mẫu giọng nói, các đặc tính chữ viết tay và nhịp gõ.\n\n**Nhận thực lẫn nhau**\nMột lĩnh vực ứng dụng quan trọng là các giao thức nhận thực lẫn nhau. Các giao thức này cho phép các bên tham gia truyền thông thuyết phục lẫn nhau về danh tính của mỗi bên và để trao đổi các khóa phiên. Trọng tâm của bài toán trao đổi khóa nhận thực là hai vấn đề: tính bảo mật và vấn đề vô hạn. Để ngăn chặn sự mạo danh và ngăn chặn sự xâm hại khóa phiên, thông tin nhận dạng và khóa phiên cần thiết phải được trao đổi ở dạng mã hóa. Thứ hai, vấn đề vô hạn là quan trọng vì nguy cơ phát lại bản tin. Sự phát lại như vậy trong trường hợp tồi tệ nhất có thể cho phép một kẻ địch xâm hại một khóa phiên hoặc mạo danh một bên nào đó thành công. Trong trường hợp ít nguy hại nhất, một tấn công phát lại thành công có thể làm phá vỡ sự vận hành bằng cách đưa cho các bên các bản tin mạo danh bản tin thật.\nCác ví dụ sau đây liệt kê các kiểu tấn công phát lại:\n(1) Tấn công phát lại đơn giản nhất là trường hợp trong đó kẻ địch chỉ đơn giản sao chép một bản tin và phát lại nó sau đó.\n(2) Một kẻ địch có thể phát lại bản tin được gắn nhãn thời gian trong cửa sổ thời gian có hiệu lực. Nếu cả bản góc và bản phát lại đến trong cùng cửa sổ thời gian, biến cố này có thể được ghi lại (logged).\n(3) Như với ví dụ (2), một kẻ địch có thể phát lại một bản tin được gắn nhãn thời gian trong cửa sổ thời gian có hiệu lực, nhưng thêm vào đó, kẻ tấn công loại bỏ bản tin gốc. Do vậy, sự lặp lại không thể bị phát hiện.\n(4) Một tấn công khác liên quan tới phát lại chiều nghịch không sửa đổi. Đây là một phát lại tới người gửi. Tấn công này là có thể xáy ra nếu mã hóa đối xứng được sử dụng và người gửi không thể dễ dàng ghi nhận sự khác biệt giữa các bản tin dược gửi và các bản tin được nhận trên cơ sở nội dung.\nMột phương pháp tiếp cận để đối phó với các tấn công phát lại là thêm vào một số thứ tự đối với mỗi bản tin được sử dụng trong một trao đổi nhận thực. Một bản tin mới được chấp nhận chỉ khi số trình tự của nó là đúng tuần tự. Khó khăn đối với tiếp cận này là nó yêu cầu mỗi bên duy trì số trình tự gần nhất đối với mỗi bên tham gia xác nhận mà nó vừa thỏa thuận. Do đó, các số trình tự thường không được sử dụng cho việc trao đổi nhận thực và khóa.\nThay vào đó, một trong các tiếp cận phổ biến sau đây được sử dụng:\n+ Các nhãn thời gian: Bên A chấp nhận bản tin là tươi mới chỉ khi bản tin chứa một nhãn thời gian mà với sự đánh giá của A, nó là đủ gần với sự hiểu biết của A về thời gian đúng. Tiếp cận này yêu cầu các đồng hồ giữa các bên tham gia khác nhau được đồng bộ.\n+ Thách đố/đáp ứng: Bên A, chấp nhận một bản tin tươi mới từ B, đầu tiên gửi B một “thách đố” và yêu cầu bản tin tiếp theo (phản hồi) nhận được từ B chứa giá trị phản hồi đúng tương ứng với thách đố.\n\n**Nhận thực một chiều**\nMã hóa đối với nhận thực một chiều được phát triển phổ biến là thư điện tử. Bản tính rất tự nhiên của thư điện tử, và các lợi ích chính của nó là không cần người gửi và người nhận trực tuyến ở tại cùng một thời điểm. Thay vào đó, bản tin thư điện tử được chuyển tiếp tới hộp thư điện tử của người nhận, nơi nó được lưu đệm cho tới khi người nhận có khả năng đọc được nó.\n“Bì thư” hoặc tiêu đề của bản tin email cần phải rõ ràng để bản tin có thể được xử lý bởi giao thức lưu và chuyển tiếp email, như giao thức truyền tải thư đơn giản (Simple Mail Tansfer Protocol - SMTP) hoặc X.400. Tuy nhiên, thông thường ta muốn giao thức xử lý không yêu cầu tiếp cận dạng bản rõ của bản tin, bởi vì điều đó yêu cầu việc tin cậy cơ chế xử lý thư. Theo đó, bản tin email cần được mã hóa và hệ thống xử lý mail không sở hữu khóa giải mã. Yêu cầu thứ hai là sự nhận thực. Thông thường, người nhận muốn một vài đảm bảo rằng bản tin đến từ đúng người gửi."
            },
            {
              "level_3_title": "5.2.2. Xác thực người dùng sử dụng mật mã khóa đối xứng",
              "level_3_id": "5.2.2",
              "content": "Xác thực lẫn nhau\nNhư đã được thảo luận ở phần trên, hai mức độ của các khóa mã hóa đối xứng có thể được sử dụng để cung cấp bảo mật cho truyền thông trong môi trường phân phối. Nhìn chung, chiến lược này liên quan đến việc sử dụng trung tâm phân phối khóa đáng tin cậy (KDC). Mỗi sự kiện trong mạng chia sẻ một khóa bí mật, được biết đến như một khóa chính, với KDC. KDC có trách nhiệm tạo các khóa được sử dụng với thời gian ngắn qua kết nối giữa hai bên, được biết như các khóa phiên, và phân phối những khóa sử dụng các khóa chính để bảo vệ sự phân tán.\nNeedham và Schroeder đưa ra một giao thức phân phối khóa bí mật sử dụng KDC gồm các đặc điểm xác thực. Giao thức có thể được tóm tắt như sau.\n1. A -> KDC: ID_A || ID_B || N1\n2. KDC -> A: E_Ka [Ks || ID_B || N1 || E_Kb[Ks || ID_A]]\n3. A -> B: E_Kb [Ks || ID_A]\n4. B -> A: E_Ks [N2]\n5. A -> B: E_Ks [f(N2)]\nCác khóa bí mật Ka và Kb được chia sẻ tương ứng giữa A với KDC và B với KDC. Mục đích của giao thức là để phân phối một cách an toàn khóa phiên Ks tới A và B. Để an toàn có được một khóa phiên mới trong bước 2. Bản tin trong bước 3 có thể được giải mã, và chỉ B mới có thể hiểu được. Bước 4 B gửi lại Ks cho A, và bước 5 A đảm bảo khóa Ks cho B, và đảm bảo với B rằng đây là bản tin mới vì sử dụng N2. Mục đích của bước 4 và 5 là để ngăn chặn một số loại tấn công phát lại.\nMặc dù việc bắt tay ở bước 4 và bước 5, giao thức vẫn có thể bị tấn công bởi tấn công phát lại. Giả sử một kẻ tấn công X đã có thể thỏa hiệp một khóa phiên cũ. Thừa nhận rằng, đây là một sự cố khó khăn hơn khi kẻ tấn công đơn giản quan sát và ghi lại bước 3. Tuy nhiên, đó là một nguy cơ bảo mật tiềm tàng. X có thể mạo danh A và lừa B sử dụng khóa cũ bằng cách phát lại bước 3. Nếu B không nhớ rằng tất cả khóa phiên vô hạn trước đó được sử dụng với A, B sẽ không thể xác định rằng đây là phát lại.\nDenning đề xuất khắc phục điểm yếu này bằng cách sửa đổi các giao thức Needham/Schroeder trong đó bao gồm việc bổ sung các tem thời gian cho các bước 2 và 3. Với giả thiết rằng khóa chính, Ka và Kb, được an toàn, và nó bao gồm các bước sau đây:\n1. A -> KDC: ID_A || ID_B\n2. KDC -> A: E_Ka [Ks || ID_B || T || E_Kb[Ks || ID_A || T]]\n3. A -> B: E_Kb [Ks || ID_A || T]\n4. B -> A: E_Ks [N1]\n5. A -> B: E_Ks [f(N1)]\nT là tem thời gian đảm bảo rằng A và B sử dụng khóa phiên mới được tạo ra. Vì thế, cả A và B biết rằng phân phối khóa là một trao đổi mới.\nGiao thức Denning tăng mức độ bảo mật cho giao thức Needham/Schroeder nhưng một mối quan tâm mới được đặt ra: cụ thể là chương trình mới này đòi hỏi phải phụ thuộc vào đồng hồ được đồng bộ trên toàn mạng và tạo ra nguy cơ khác. Nguy cơ này được dựa trên sự thật rằng các đồng hộ được phân phối có thể không được đồng bộ với việc đồng hồ bị phá hoại hoặc lỗi trong các cơ chế đồng bộ. Vấn đề xảy ra khi đồng hồ của người gửi nhanh hơn đồng hồ của người nhận. Trong trường hợp này, có cơ hội có thể bị đánh chặn một bản tin từ phía người gửi và phát lại nó sau đó. Một cách để đối phó với các cuộc tấn công phát lại-bỏ gói tin là thực thi những yêu cầu thường xuyên kiểm tra đồng hồ của họ dựa vào đồng hồ của KDC. Ngoài ra, việc cần đồng bộ hóa đồng hồ có thể dựa trên giao thức bắt tay sử dụng nonce. Các giao thức Needham/Schroeder dựa trên nonce vẫn có một vài lỗ hổng và được cải thiện như sau:\n1. A -> B: ID_A || Na\n2. B -> KDC: ID_B || Nb || E_Kb [ID_A || Na || Tb]\n3. KDC -> A: E_Ka [ID_B || Na || Ks || Tb] || E_Kb [ID_A || Ks || Tb || Nb]\n4. A -> B: E_Kb [ID_A || Ks || Tb || Nb] || E_Ks [Na || Nb]\nGiao thức này cung cấp một cách hiệu quả, phương tiện an toàn cho A và B để thiết lập một phiên làm việc với một khóa phiên an toàn.\nXác thực một chiều\nTrong kịch bản mã hóa đối xứng thì kịch bản phân bổ khóa phân tán là không thực tế. Cơ chế này yêu cầu phía người gửi đặt ra một yêu cầu đến người nhận đã xác định từ trước, đợi một đáp ứng chứa một khóa phiên, và sau đó chỉ gửi một bản tin. Với một vài phương pháp cải tiến, sử dụng KDC là một ứng cử viên cho mã hóa thư điện tử.\n1. A -> KDC: ID_A || ID_B || N1\n2. KDC -> A: E_Ka [Ks || ID_B || N1 || E_Kb[Ks || ID_A]]\n3. A -> B: E_Kb [Ks || ID_A] || E_Ks [M]\nHướng tiếp cận này đảm bảo rằng chỉ người nhận được xác định trước của bản tin mới có thể đọc nó. Nó cũng cung cấp một mức nhận thực mà người gửi là A. Như đã chỉ rõ ở trên giao thức này không chống lại được kiểu tấn công phát lại. Một vài giới hạn phòng thủ có thể được cung cấp bằng cách gán thêm một tem thời gian (timestamp) với bản tin. Tuy nhiên, vì các trễ tiềm ẩn trong tiến trình gửi thư điện tử, nên các tem thời gian bị giới hạn về tính hữu dụng."
            }
          ]
        },
        {
          "level_2_title": "5.3. Câu hỏi ôn tập chương 5",
          "level_2_id": "5.3",
          "content": "1. Tóm lược đặc điểm cơ bản của các mô hình phân phối khóa\n2. Các đặc trưng cơ bản của chứng chỉ số X509\n3. Nguyên tắc xác thực người dùng từ xa\n4. Đặc trưng xác thực người dùng sử dụng mật mã khóa đối xứng",
          "children": []
        }
      ]
    }
  ]
}
